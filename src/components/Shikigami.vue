<script lang="ts">
import type { observerType } from './Observer.vue'
import { SvgClass } from './Svg.vue'
import type { svgType } from './Svg.vue'
import { AstroClass } from './Astro.vue'
import { SuntimeClass } from './Suntime.vue'
import type { SuntimeType, timeBase } from './Suntime.vue'
import { planets } from './Planet.vue'
import type { Star, Satellite } from './Planet.vue'
import { drawEarth } from './shikigami/ShikigamiSun.vue'
import { drawMoon } from './shikigami/ShikigamiMoon.vue'
import { drawGraph } from './shikigami/ShikigamiGraph.vue'
const { Sun, Moon, Mercury, Venus, Mars } = planets()


// 定数
const RAD = Math.PI / 180;
const SVG_LINE_WIDTH = 0.25;
const SVG_WIDTH = 1683.7795;
const SVG_HEIGHT = 2383.937;
const SVG_LEFT = 841.8896;
const SVG_TOP = 1191.9687;
const SVG_AUR = 424.0488; // 1AU = 424.0488px
const WHITE_COLOR = '#FFFFFF';
const BLACK_COLOR = '#000000';
const RED_COLOR = '#FF0000';
const GREEN_COLOR = '#33CC33';

let svg: svgType;

function downloadSVG() {
  svg.download();
}


type DaysData = {
  start: Date
  end: Date
  data: Array<{ date: number, value: number }>
}
// SHIKIGAMIメインルーチン
export const shikigami = (observer: observerType, flagDraw: {
  isDrawEarth: boolean,
  isDrawMoon: boolean,
  isDrawMercury: boolean,
  isDrawVenus: boolean,
  isDrawMars: boolean,
  isDrawJupiter: boolean,
  isDrawSaturn: boolean,
  isDrawUranus: boolean,
  isDrawNeptune: boolean,
  isDrawPluto: boolean,
  isDrawSunrise: boolean,
  isDrawSunset: boolean,
  isDrawDayArea: boolean,
  isDrawNightArea: boolean,
}, eachDaysData: DaysData, drawTime: timeBase) => {
  let svgImage;
  let flagSunrise: boolean, flagSunset: boolean;
  let flagDay: boolean, flagNight: boolean;
  let flagDrawTime: boolean;
  const svgLineR = 583.54395;
  const svgSize = 1.723;

  svg = new SvgClass(observer.initDt, SVG_WIDTH, SVG_HEIGHT, SVG_LEFT, SVG_TOP);
  // 通日ラベルフォント
  svg.tag(`<style>.days{font-family: DroidSans, Droid Sans; font-size: 3.2px; color: #000000; stroke-width: 0.25; text-anchor: middle;}</style>`);
  svg.groupId(`ガイド基準`);
  svg.groupId(`中心点`);
  svg.circle(0, 0, svgSize, SVG_LINE_WIDTH, BLACK_COLOR, WHITE_COLOR,);
  svg.groupFooter();
  svg.groupId(`春分点方向線`);
  svg.line(0, 0, svgLineR, 0, SVG_LINE_WIDTH, RED_COLOR);
  svg.groupFooter();
  svg.groupFooter();

  // 描画フラグ設定
  flagSunrise = flagDraw.isDrawSunrise;
  flagSunset = flagDraw.isDrawSunset;
  flagDay = flagDraw.isDrawDayArea;
  flagNight = flagDraw.isDrawNightArea;

  // 描画基準時刻設定
  flagDrawTime = drawTime === 'clock';

  // 惑星描画
  if (flagDraw.isDrawEarth) { drawEarth(svg, observer, flagSunrise, flagSunset, flagDay, flagNight, drawTime,); }
  if (flagDraw.isDrawEarth) { drawGraph(svg, observer, drawTime, eachDaysData); }
  if (flagDraw.isDrawMoon) { drawMoon(svg, observer, drawTime); }
  if (flagDraw.isDrawMercury) { drawMercury(svg, observer, flagDrawTime); }
  if (flagDraw.isDrawVenus) { drawVenus(svg, observer, flagDrawTime); }
  if (flagDraw.isDrawMars) { drawMars(svg, observer, flagDrawTime); }
  // if (flagDraw.isDrawJupiter) { isDrawJupiter(o, flagDrawTime); }
  // if (flagDraw.isDrawSaturn) { isDrawSaturn(o, flagDrawTime); }
  // if (flagDraw.isDrawUranus) { isDrawUranus(o, flagDrawTime); }
  // if (flagDraw.isDrawNeptune) { isDrawNeptune(o, flagDrawTime); }
  // if (flagDraw.isDrawPluto) { isDrawPluto(o, flagDrawTime); }

  svg.groupId(`出力情報`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 210})">描画開始日：${observer.initDt.toLocaleDateString()}</text>`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 180})">描画場所：${observer.name} 経度 ${observer.longitude} / 緯度 ${observer.latitude} / タイムゾーン UTC+${observer.timezone}</text>`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 150})">描画基準時刻：${flagDrawTime ? '正午／正子' : '南中／北中'}</text>`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 100})">Generated by SHIKIGAMI 2.1.3 / Copyright(C)2021 Will System Design</text>`);
  svg.groupFooter();
  svg.end();

  svgImage = document.getElementById('svgImage') as HTMLElement;
  svgImage.innerHTML = svg.string;
}

type PlanetPositions = {
  datetimeString: string,
  r: number,
  y: number,
}[];

// 水星
function drawMercury(svg: svgType, observer: observerType, flagDrawTime: boolean) {
  const svgInR = 130.3795, svgOutR = 197.8724;
  const svgSize = 0.69;
  const strokeColor = '#231815';
  const rotateDays = 88;
  let drawDt;
  let suntime;
  let mjd, t;
  let mercury;
  let mercuryBall: PlanetPositions = [];
  let compassY;
  let d;

  // 最初の要素
  drawDt = new Date(observer.initDt);
  suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
  } else {
    mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
  }
  t = AstroClass.t(mjd);
  mercury = new Mercury(t);

  // 水星玉
  compassY = mercury.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    // mercuryBall[1] = [suntime.noonDt.toLocaleString(), mercury.r, compassY];
    mercuryBall[1] = { datetimeString: suntime.noonDt.toLocaleString(), r: mercury.r, y: compassY };
  } else {
    // mercuryBall[1] = [suntime.southDt.toLocaleString(), mercury.r, compassY];
    mercuryBall[1] = { datetimeString: suntime.southDt.toLocaleString(), r: mercury.r, y: compassY };
  }

  // 最終までの要素ループ
  for (d = 2; d <= rotateDays; d++) {
    drawDt.setDate(drawDt.getDate() + 1);

    suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
    } else {
      mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
    }
    t = AstroClass.t(mjd);
    mercury = new Mercury(t);

    // 水星玉
    compassY = mercury.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mercuryBall[d] = { datetimeString: suntime.noonDt.toLocaleString(), r: mercury.r, y: compassY };
    } else {
      mercuryBall[d] = { datetimeString: suntime.southDt.toLocaleString(), r: mercury.r, y: compassY };
    }
  }

  // ここから水星SVG作成
  svg.groupId(`水星`);

  svg.groupId(`水星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`水星玉 ${mercuryBall[1].datetimeString}`);
  svg.circle(SVG_AUR * mercuryBall[1].r, mercuryBall[1].y, svgSize, SVG_LINE_WIDTH, GREEN_COLOR, `none`);
  svg.groupFooter();

  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`水星玉 ${mercuryBall[d].datetimeString}`);
    svg.circle(SVG_AUR * mercuryBall[d].r, mercuryBall[d].y, svgSize, SVG_LINE_WIDTH, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`水星移動線`);
  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`水星移動線 ${mercuryBall[d].datetimeString}`);
    svg.line(SVG_AUR * mercuryBall[d - 1].r, mercuryBall[d - 1].y, SVG_AUR * mercuryBall[d].r, mercuryBall[d].y, SVG_LINE_WIDTH, BLACK_COLOR);
    svg.groupFooter();
  }
  svg.groupId(`水星移動線 閉じる`);
  svg.line(SVG_AUR * mercuryBall[rotateDays].r, mercuryBall[rotateDays].y, SVG_AUR * mercuryBall[1].r, mercuryBall[1].y, SVG_LINE_WIDTH, BLACK_COLOR);
  svg.groupFooter();

  svg.groupFooter();

  svg.groupId(`水星近点軌道`);
  svg.circle(0, 0, svgInR, SVG_LINE_WIDTH, RED_COLOR, `none`);
  svg.groupFooter();
  svg.groupId(`水星遠点軌道`);
  svg.circle(0, 0, svgOutR, SVG_LINE_WIDTH, RED_COLOR, `none`);
  svg.groupFooter();

  svg.groupFooter();
}

// 金星
function drawVenus(svg: svgType, observer: observerType, flagDrawTime: boolean) {
  const svgInR = 304.611, svgOutR = 308.7921;
  const svgSize = 1.72;
  const strokeColor = '#231815';
  const rotateDays = 225;
  let drawDt;
  let suntime;
  let mjd, t;
  let venus;
  let venusBall: PlanetPositions = [];
  let compassY
  let d;

  // 最初の要素
  drawDt = new Date(observer.initDt);
  suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
  } else {
    mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
  }
  t = AstroClass.t(mjd);
  venus = new Venus(t);

  // 金星玉
  compassY = venus.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    venusBall[1] = { datetimeString: suntime.noonDt.toLocaleString(), r: venus.r, y: compassY };
  } else {
    venusBall[1] = { datetimeString: suntime.southDt.toLocaleString(), r: venus.r, y: compassY };
  }

  // 最終までの要素ループ
  for (d = 2; d <= rotateDays; d++) {
    drawDt.setDate(drawDt.getDate() + 1);
    suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
    } else {
      mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
    }
    t = AstroClass.t(mjd);
    venus = new Venus(t);

    // 金星玉
    compassY = venus.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      venusBall[d] = { datetimeString: suntime.noonDt.toLocaleString(), r: venus.r, y: compassY };
    } else {
      venusBall[d] = { datetimeString: suntime.southDt.toLocaleString(), r: venus.r, y: compassY };
    }
  }

  // ここから金星SVG作成
  svg.groupId(`金星`);

  svg.groupId(`金星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`金星玉 ${venusBall[1].datetimeString}`);
  svg.circle(SVG_AUR * venusBall[1].r, venusBall[1].y, svgSize, SVG_LINE_WIDTH, GREEN_COLOR, `none`);
  svg.groupFooter();

  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`金星玉 ${venusBall[d].datetimeString}`);
    svg.circle(SVG_AUR * venusBall[d].r, venusBall[d].y, svgSize, SVG_LINE_WIDTH, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`金星移動線`);
  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`金星移動線 ${venusBall[d].datetimeString}`);
    svg.line(SVG_AUR * venusBall[d - 1].r, venusBall[d - 1].y, SVG_AUR * venusBall[d].r, venusBall[d].y, SVG_LINE_WIDTH, BLACK_COLOR);
    svg.groupFooter();
  }
  svg.groupId(`金星移動線 閉じる`);
  svg.line(SVG_AUR * venusBall[rotateDays].r, venusBall[rotateDays].y, SVG_AUR * venusBall[1].r, venusBall[1].y, SVG_LINE_WIDTH, BLACK_COLOR);
  svg.groupFooter();

  svg.groupFooter();

  svg.groupId(`金星近点軌道`);
  svg.circle(0, 0, svgInR, SVG_LINE_WIDTH, RED_COLOR, `none`);
  svg.groupFooter();
  svg.groupId(`金星遠点軌道`);
  svg.circle(0, 0, svgOutR, SVG_LINE_WIDTH, RED_COLOR, `none`);
  svg.groupFooter();

  svg.groupFooter();
}



// 火星
function drawMars(svg: svgType, observer: observerType, flagDrawTime: boolean) {
  const svgInR = 585.71316, svgOutR = 706.40593;
  const svgSize = 0.96;
  const strokeColor = '#333333';
  const rotateDays = 687;
  let drawDt;
  let suntime;
  let mjd, t;
  let mars;
  let marsBall: PlanetPositions = [];
  let compassY;
  let d;

  // 最初の要素
  drawDt = new Date(observer.initDt);
  suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
  } else {
    mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
  }
  t = AstroClass.t(mjd);
  mars = new Mars(t);

  // 火星玉
  compassY = mars.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }

  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    marsBall[1] = { datetimeString: suntime.noonDt.toLocaleString(), r: mars.r, y: compassY };
  } else {
    marsBall[1] = { datetimeString: suntime.southDt.toLocaleString(), r: mars.r, y: compassY };
  }

  // 最終までの要素ループ
  for (d = 2; d <= rotateDays; d++) {
    drawDt.setDate(drawDt.getDate() + 1);
    suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
    } else {
      mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
    }
    t = AstroClass.t(mjd);
    mars = new Mars(t);

    // 火星玉
    compassY = mars.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      marsBall[d] = { datetimeString: suntime.noonDt.toLocaleString(), r: mars.r, y: compassY };
    } else {
      marsBall[d] = { datetimeString: suntime.southDt.toLocaleString(), r: mars.r, y: compassY };
    }
  }

  // ここから火星SVG作成
  svg.groupId(`火星`);

  svg.groupId(`火星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`火星玉 ${marsBall[1].datetimeString}`);
  svg.circle(SVG_AUR * marsBall[1].r, marsBall[1].y, svgSize, SVG_LINE_WIDTH, GREEN_COLOR, `none`);
  svg.groupFooter();

  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`火星玉 ${marsBall[d].datetimeString}`);
    svg.circle(SVG_AUR * marsBall[d].r, marsBall[d].y, svgSize, SVG_LINE_WIDTH, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`火星移動線`);
  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`火星移動線 ${marsBall[d].datetimeString}`);
    svg.line(SVG_AUR * marsBall[d - 1].r, marsBall[d - 1].y, SVG_AUR * marsBall[d].r, marsBall[d].y, SVG_LINE_WIDTH, BLACK_COLOR);
    svg.groupFooter();
  }
  svg.groupId(`火星移動線 閉じる`);
  svg.line(SVG_AUR * marsBall[rotateDays].r, marsBall[rotateDays].y, SVG_AUR * marsBall[1].r, marsBall[1].y, SVG_LINE_WIDTH, BLACK_COLOR);
  svg.groupFooter();

  svg.groupFooter();

  svg.groupId(`火星近点軌道`);
  svg.circle(0, 0, svgInR, SVG_LINE_WIDTH, RED_COLOR, `none`);
  svg.groupFooter();
  svg.groupId(`火星遠点軌道`);
  svg.circle(0, 0, svgOutR, SVG_LINE_WIDTH, RED_COLOR, `none`);
  svg.groupFooter();

  svg.groupFooter();
}

let defaultObject = {};
export default defaultObject;
</script>

