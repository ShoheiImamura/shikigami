<script lang="ts">
import type { observerType } from './Observer.vue'
import { SvgClass } from './Svg.vue'
import type { svgType } from './Svg.vue'
import { AstroClass } from './Astro.vue'
import { SuntimeClass } from './Suntime.vue'
import type { SuntimeType, timeBase } from './Suntime.vue'
import { planets } from './Planet.vue'
import type { Star, Satellite } from './Planet.vue'
const { Sun, Moon } = planets()

// 定数
const RAD = Math.PI / 180;
const SVG_LINE_WIDTH = 0.25;
const SVG_WIDTH = 1683.7795;
const SVG_HEIGHT = 2383.937;
const SVG_LEFT = 841.8896;
const SVG_TOP = 1191.9687;
const SVG_AUR = 424.0488; // 1AU = 424.0488px
const WHITE_COLOR = '#FFFFFF';
const BLACK_COLOR = '#000000';
const RED_COLOR = '#FF0000';
const GREEN_COLOR = '#33CC33';

let svg: svgType;

function downloadSVG() {
  svg.download();
}


type DaysData = {
  start: Date
  end: Date
  data: Array<{ date: number, value: number }>
}
// SHIKIGAMIメインルーチン
export const shikigami = (observer: observerType, flagDraw: {
  isDrawEarth: boolean,
  isDrawMoon: boolean,
  isDrawMercury: boolean,
  isDrawVenus: boolean,
  isDrawMars: boolean,
  isDrawJupiter: boolean,
  isDrawSaturn: boolean,
  isDrawUranus: boolean,
  isDrawNeptune: boolean,
  isDrawPluto: boolean,
  isDrawSunrise: boolean,
  isDrawSunset: boolean,
  isDrawDayArea: boolean,
  isDrawNightArea: boolean,
}, eachDaysData: DaysData, drawTime: timeBase) => {
  let svgImage;
  let flagSunrise: boolean, flagSunset: boolean;
  let flagDay: boolean, flagNight: boolean;
  let flagDrawTime: boolean;
  const svgLineR = 583.54395;
  const svgSize = 1.723;

  svg = new SvgClass(observer.initDt, SVG_WIDTH, SVG_HEIGHT, SVG_LEFT, SVG_TOP);
  // 通日ラベルフォント
  svg.tag(`<style>.days{font-family: DroidSans, Droid Sans; font-size: 3.2px; color: #000000; stroke-width: 0.25; text-anchor: middle;}</style>`);
  svg.groupId(`ガイド基準`);
  svg.groupId(`中心点`);
  svg.circle(0, 0, svgSize, SVG_LINE_WIDTH, BLACK_COLOR, WHITE_COLOR,);
  svg.groupFooter();
  svg.groupId(`春分点方向線`);
  svg.line(0, 0, svgLineR, 0, SVG_LINE_WIDTH, RED_COLOR);
  svg.groupFooter();
  svg.groupFooter();

  // 描画フラグ設定
  flagSunrise = flagDraw.isDrawSunrise;
  flagSunset = flagDraw.isDrawSunset;
  flagDay = flagDraw.isDrawDayArea;
  flagNight = flagDraw.isDrawNightArea;

  // 描画基準時刻設定
  flagDrawTime = drawTime === 'clock';

  // 惑星描画
  if (flagDraw.isDrawEarth) { drawSun(observer, flagSunrise, flagSunset, flagDay, flagNight, drawTime, eachDaysData); }
  if (flagDraw.isDrawMoon) { isDrawMoon(observer, flagDrawTime); }
  // if (flagDraw.isDrawMercury) { isDrawMercury(o, flagDrawTime); }
  // if (flagDraw.isDrawVenus) { isDrawVenus(o, flagDrawTime); }
  // if (flagDraw.isDrawMars) { isDrawMars(o, flagDrawTime); }
  // if (flagDraw.isDrawJupiter) { isDrawJupiter(o, flagDrawTime); }
  // if (flagDraw.isDrawSaturn) { isDrawSaturn(o, flagDrawTime); }
  // if (flagDraw.isDrawUranus) { isDrawUranus(o, flagDrawTime); }
  // if (flagDraw.isDrawNeptune) { isDrawNeptune(o, flagDrawTime); }
  // if (flagDraw.isDrawPluto) { isDrawPluto(o, flagDrawTime); }

  svg.groupId(`出力情報`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 210})">描画開始日：${observer.initDt.toLocaleDateString()}</text>`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 180})">描画場所：${observer.name} 経度 ${observer.longitude} / 緯度 ${observer.latitude} / タイムゾーン UTC+${observer.timezone}</text>`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 150})">描画基準時刻：${flagDrawTime ? '正午／正子' : '南中／北中'}</text>`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 100})">Generated by SHIKIGAMI 2.1.3 / Copyright(C)2021 Will System Design</text>`);
  svg.groupFooter();
  svg.end();

  svgImage = document.getElementById('svgImage') as HTMLElement;
  svgImage.innerHTML = svg.string;
}

const createSunbyDt = (date: Date, timezone: number) => {
  const mjd = AstroClass.mjd(date, timezone);
  const T = AstroClass.t(mjd);
  return new Sun(T);
}

/**
 * １年間の日数
 * @param startDate 開始日
 * @return 1年間の日数
 */
const rotateDaysFromStartDate = (startDate: Date): number => {
  const startDt = new Date(startDate);
  const endDt = new Date(startDate);
  endDt.setFullYear(endDt.getFullYear() + 1);
  return (endDt.getTime() - startDt.getTime()) / (1000 * 60 * 60 * 24);
}

// 描画関数
/** 地球（太陽） */
const drawSun = (observer: observerType,
  flagSunrise: boolean, flagSunset: boolean, flagDay: boolean, flagNight: boolean,
  drawTime: timeBase, eachDaysData: DaysData) => {
  const svgInR = 416.9622; // 地球近点軌道の半径(px)
  const svgOutR = 431.13545; // 地球遠点軌道の半径(px)
  const svgLineR = 583.54395;
  const svgDaysR = svgOutR + 2; // 通日ラベルの描画半径(地球遠点軌道の少し外側)(px)
  const svgSize = 1.723;
  const strokeColor = '#231815';
  const guideSunriseColor = '#FF9900', guideSunsetColor = '#CC6600';
  let sunDateLine: { suntimeDt: string, sunR: number, sunY: number }[] = [];
  let sunriseLine: { sunriseDt: Date, sunriseR: number, sunriseY: number }[] = [];
  let sunsetLine: { sunsetDt: Date, sunsetR: number, sunsetY: number }[] = [];
  let earthBall: { suntimeDt: string, sunR: number, sunY: number }[] = [];
  let sunNumber: { suntimeDt: string, sunY: number, }[] = [];

  // 1周の日数
  const rotateDays = rotateDaysFromStartDate(observer.initDt);
  let drawDt = new Date(observer.initDt);
  for (let dateIndex = 1; dateIndex <= rotateDays; dateIndex++) {
    const suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);

    // 日付線
    const midnightSun = createSunbyDt(suntime.startDt(drawTime), observer.timezone); // 真夜中
    sunDateLine[dateIndex] = { suntimeDt: suntime.startDt(drawTime).toLocaleString(), sunR: midnightSun.r, sunY: midnightSun.y };
    // 日の出線
    const sunrise = createSunbyDt(suntime.sunriseDt, observer.timezone); // 日の出
    sunriseLine[dateIndex] = { sunriseDt: suntime.sunriseDt, sunriseR: sunrise.r, sunriseY: sunrise.y };
    // 日の入り線
    const sunset = createSunbyDt(suntime.sunsetDt, observer.timezone); // 日の入
    sunsetLine[dateIndex] = { sunsetDt: suntime.sunsetDt, sunsetR: sunset.r, sunsetY: sunset.y };

    // 真昼
    const noonSun = createSunbyDt(suntime.middleDt(drawTime), observer.timezone);
    // 地球玉の位置
    earthBall[dateIndex] = { suntimeDt: suntime.middleDt(drawTime).toLocaleString(), sunR: noonSun.r, sunY: noonSun.y };
    // 通日ラベル（001～365,366）
    sunNumber[dateIndex] = { suntimeDt: suntime.middleDt(drawTime).toLocaleString(), sunY: noonSun.y, };

    drawDt.setDate(drawDt.getDate() + 1); // 次の日付
  }

  // ここから地球SVG生成
  svg.groupId(`地球`);
  // 地球玉を描画
  drawSvgEarthBalls(svg, earthBall, rotateDays, svgSize, strokeColor);
  // 通日ラベルを描画
  drawSvgDateLabels(svg, sunNumber, rotateDays, svgDaysR);
  // 地球移動線を描画
  drawSvgEarthOrbits(svg, earthBall, rotateDays,);
  // 地球近点軌道を描画
  drawSvgEarthPerigee(svg, svgInR);
  // 地球遠点軌道を描画
  drawSvgEarthApogee(svg, svgOutR);

  // 日付線を描画
  drawSvgDateLines(svg, sunDateLine, rotateDays, svgLineR, strokeColor);
  // 日の出線を描画
  if (flagSunrise) { drawSvgSunriseLines(svg, sunriseLine, rotateDays, svgLineR, guideSunriseColor); };
  // 日の入線を描画
  if (flagSunset) { drawSvgSunsetLines(svg, sunsetLine, rotateDays, svgLineR, guideSunsetColor); };
  // 昼エリアを描画
  if (flagDay) { drawSvgDaytimeAreas(svg, sunriseLine, sunsetLine, rotateDays, svgLineR, guideSunriseColor); }
  // 夜エリアを描画
  if (flagNight) { drawSvgNighttimeAreas(svg, sunriseLine, sunsetLine, rotateDays, svgLineR, guideSunsetColor); }

  // 追加グラフ
  drawSvgInputDataGraph(svg, eachDaysData, sunsetLine, rotateDays);

  svg.groupFooter();
}

/**  日付線をSVG描画 */
const drawSvgDateLines = (
  svg: svgType,
  sunDateLine: { suntimeDt: string, sunR: number, sunY: number }[] = [],
  rotateDays: number,
  svgLineR: number,
  strokeColor: string = '#231815',
) => {
  svg.groupId(`日付線`);
  for (let dateIndex = 1; dateIndex <= rotateDays; dateIndex++) {
    const color = (dateIndex === 1) ? GREEN_COLOR : strokeColor;
    svg.groupId(`日付線 ${sunDateLine[dateIndex].suntimeDt}`);
    svg.line(SVG_AUR * sunDateLine[dateIndex].sunR, sunDateLine[dateIndex].sunY, svgLineR, sunDateLine[dateIndex].sunY, SVG_LINE_WIDTH, color);
    svg.groupFooter();
  }
  svg.groupFooter();
}

/** 日の出線をSVG描画 */
const drawSvgSunriseLines = (
  svg: svgType,
  sunriseLine: { sunriseDt: Date; sunriseR: number; sunriseY: number; }[],
  rotateDays: number,
  svgLineR: number,
  guideSunriseColor: string = '#FF9900'
) => {
  svg.groupId(`日の出線`);
  for (let dateIndex = 1; dateIndex <= rotateDays; dateIndex++) {
    svg.groupId(`日の出線 ${sunriseLine[dateIndex].sunriseDt.toLocaleString()}`);
    svg.line(SVG_AUR * sunriseLine[dateIndex].sunriseR, sunriseLine[dateIndex].sunriseY, svgLineR, sunriseLine[dateIndex].sunriseY, SVG_LINE_WIDTH, guideSunriseColor);
    svg.groupFooter();
  }
  svg.groupFooter();
}

/** 日の入線をSVG描画 */
const drawSvgSunsetLines = (
  svg: svgType,
  sunsetLine: { sunsetDt: Date; sunsetR: number; sunsetY: number; }[],
  rotateDays: number,
  svgLineR: number,
  guideSunsetColor: string = '#CC6600'
) => {
  svg.groupId(`日の入り線`);
  for (let dateIndex = 1; dateIndex <= rotateDays; dateIndex++) {
    svg.groupId(`日の入り線 ${sunsetLine[dateIndex].sunsetDt.toLocaleString()}`);
    svg.line(SVG_AUR * sunsetLine[dateIndex].sunsetR, sunsetLine[dateIndex].sunsetY, svgLineR, sunsetLine[dateIndex].sunsetY, SVG_LINE_WIDTH, guideSunsetColor);
    svg.groupFooter();
  }
  svg.groupFooter();
}

/** 昼エリアをSVG描画 */
const drawSvgDaytimeAreas = (
  svg: svgType,
  sunriseLine: { sunriseDt: Date; sunriseR: number; sunriseY: number; }[],
  sunsetLine: { sunsetDt: Date; sunsetR: number; sunsetY: number; }[],
  rotateDays: number,
  svgLineR: number,
  guideSunriseColor: string = '#FF9900',
) => {
  svg.groupId(`昼エリア`);
  for (let dateIndex = 1; dateIndex <= rotateDays; dateIndex++) {
    svg.groupId(`'昼エリア' + ${sunriseLine[dateIndex].sunriseDt.toLocaleString()} ${sunsetLine[dateIndex].sunsetDt.toLocaleString()}`);
    svg.area(SVG_AUR * sunriseLine[dateIndex].sunriseR, sunriseLine[dateIndex].sunriseY, SVG_AUR * sunsetLine[dateIndex].sunsetR, sunsetLine[dateIndex].sunsetY, svgLineR, SVG_LINE_WIDTH, guideSunriseColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();
}

/** 夜エリアをSVG描画 */
const drawSvgNighttimeAreas = (
  svg: svgType,
  sunriseLine: { sunriseDt: Date; sunriseR: number; sunriseY: number; }[],
  sunsetLine: { sunsetDt: Date; sunsetR: number; sunsetY: number; }[],
  rotateDays: number,
  svgLineR: number,
  guideSunsetColor: string = '#CC6600'
) => {
  svg.groupId(`夜エリア`);
  for (let dateIndex = 1; dateIndex <= rotateDays; dateIndex++) {
    const nextDay = (dateIndex === rotateDays) ? 1 : dateIndex + 1;// 最終の夜エリアは開始日の日の出時間につなぐ
    svg.groupId(`夜エリア ${sunsetLine[dateIndex].sunsetDt.toLocaleString()} ${sunriseLine[nextDay].sunriseDt.toLocaleString()}`);
    svg.area(SVG_AUR * sunriseLine[nextDay].sunriseR, sunriseLine[nextDay].sunriseY, SVG_AUR * sunsetLine[dateIndex].sunsetR, sunsetLine[dateIndex].sunsetY, svgLineR, SVG_LINE_WIDTH, guideSunsetColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();
}

/** 地球玉をSVG描画 */
const drawSvgEarthBalls = (
  svg: svgType,
  earthBall: { suntimeDt: string; sunR: number; sunY: number; }[],
  rotateDays: number,
  svgSize: number,
  strokeColor: string = "#231815"
) => {
  svg.groupId(`地球玉`);
  for (let dateIndex = 1; dateIndex <= rotateDays; dateIndex++) {
    const color = (dateIndex === 1) ? GREEN_COLOR : strokeColor; // 最初の地球玉だけ色を変える
    svg.groupId(`地球玉 ${earthBall[dateIndex].suntimeDt}`);
    svg.circle(SVG_AUR * earthBall[dateIndex].sunR, earthBall[dateIndex].sunY, svgSize, SVG_LINE_WIDTH, color, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();
};

/** 通日ラベルをSVG描画 */
const drawSvgDateLabels = (
  svg: svgType,
  sunNumber: { suntimeDt: string; sunY: number; }[],
  rotateDays: number,
  svgDaysR: number,
) => {

  svg.groupId(`通日ラベル`);
  for (let dateIndex = 1; dateIndex <= rotateDays; dateIndex++) {
    let daysAngle: number;
    let offsetR: number;
    // 通日ラベルの表示方向
    if (sunNumber[dateIndex].sunY >= 180) { // 春分～夏～秋分の間
      daysAngle = 270 - sunNumber[dateIndex].sunY;
      offsetR = 2.25;
    } else { // 春分～夏～秋分の間
      daysAngle = 90 - sunNumber[dateIndex].sunY;
      offsetR = 0;
    }
    svg.groupId(`通日ラベル${('000' + dateIndex).slice(-3)} ${sunNumber[dateIndex].suntimeDt}`);
    svg.text('days', svgDaysR + offsetR, sunNumber[dateIndex].sunY, daysAngle, ('000' + dateIndex).slice(-3));
    svg.groupFooter();
  }
  svg.groupFooter();
}

/** 地球移動線をSVG描画 */
const drawSvgEarthOrbits = (
  svg: svgType,
  earthBall: { suntimeDt: string; sunR: number; sunY: number; }[],
  rotateDays: number,
) => {
  svg.groupId(`地球移動線`);
  for (let dateIndex = 1; dateIndex <= rotateDays; dateIndex++) {
    const nextDay = (dateIndex === rotateDays) ? 1 : dateIndex + 1;
    svg.groupId(`地球移動線 ${earthBall[dateIndex].suntimeDt}`);
    svg.line(SVG_AUR * earthBall[dateIndex].sunR, earthBall[dateIndex].sunY, SVG_AUR * earthBall[nextDay].sunR, earthBall[nextDay].sunY, SVG_LINE_WIDTH, BLACK_COLOR);
    svg.groupFooter();
  }
  svg.groupFooter();
}

/** 地球近点軌道をSVG描画 */
const drawSvgEarthPerigee = (
  svg: svgType,
  svgInR: number,
) => {
  svg.groupId(`地球近点軌道`);
  svg.circle(0, 0, svgInR, SVG_LINE_WIDTH, RED_COLOR, `none`);
  svg.groupFooter();
}

/** 地球遠点軌道をSVG描画 */
const drawSvgEarthApogee = (
  svg: svgType,
  svgOutR: number,
) => {
  svg.groupId(`地球遠点軌道`);
  svg.circle(0, 0, svgOutR, SVG_LINE_WIDTH, RED_COLOR, `none`);
  svg.groupFooter();
}

/** 任意の円環棒グラフを地球の日付ラインにSVG描画する */
const drawSvgInputDataGraph = (
  svg: svgType,
  eachDaysData: DaysData,
  sunsetLine: { sunsetDt: Date; sunsetR: number; sunsetY: number; }[],
  rotateDays: number,
) => {
  svg.groupId(`円環棒グラフ`);
  for (let dateIndex = 1; dateIndex <= rotateDays; dateIndex++) {
    const daysValue = eachDaysData.data[dateIndex] ? eachDaysData.data[dateIndex].value : 0
    if (!isNaN(sunsetLine[dateIndex].sunsetDt.getTime())) {
      svg.groupId(`円環棒グラフ ${sunsetLine[dateIndex].sunsetDt.toLocaleString()}`);
      svg.line(SVG_AUR * sunsetLine[dateIndex].sunsetR,
        sunsetLine[dateIndex].sunsetY,
        SVG_AUR * sunsetLine[dateIndex].sunsetR + daysValue,
        sunsetLine[dateIndex].sunsetY,
        6,
        'blue');
      svg.groupFooter();
    }
  }
  svg.groupFooter();
}


/** 月 */
const isDrawMoon = (observer: observerType, flagDrawTime: boolean) => {
  const svgSmallSize = 0.4;
  const svgBigSize = 2.601;
  const strokeColor = '#231815';
  const fullmoonColor = '#FCC800', newmoonColor = '#3e3a39';
  let startDt: Date, endDt: Date, rotateHours: number;
  let drawDt: Date;
  let suntime: SuntimeType;
  let mjd: number, t: number;
  let sun: Star, moon: Satellite;
  let moonBall: { dtString: string, sunR: number, angleCos: number, sunY: number }[] = [];
  let fullmoonBall: { dtString: string, sunR: number, angleCos: number, sunY: number }[] = [];
  let newmoonBall: { dtString: string, sunR: number, angleCos: number, sunY: number }[] = [];
  let angleCos: number;
  let pre1sun: Star, pre1moon: Satellite, pre1Dt: Date, pre1Cos: number, pre1R: number, pre1Y: number, pre2Cos: number;
  let dateIndex: number;

  // 1周の描画数を決める（日数×6時間毎）
  startDt = new Date(observer.initDt);
  endDt = new Date(observer.initDt);
  endDt.setFullYear(endDt.getFullYear() + 1);
  rotateHours = (endDt.getTime() - startDt.getTime()) / (1000 * 60 * 60) / 6;

  // 最初の夜起点要素
  suntime = new SuntimeClass(observer.initDt, observer.longitude, observer.latitude, observer.timezone);
  // 正子にするか北中にするか選ぶ
  drawDt = new Date(flagDrawTime ? suntime.initDt : suntime.northDt);

  // 月波
  mjd = AstroClass.mjd(drawDt, observer.timezone);
  t = AstroClass.t(mjd);
  sun = new Sun(t);
  moon = new Moon(t);
  angleCos = -Math.cos((moon.y - sun.y) * RAD);
  moonBall[1] = { dtString: drawDt.toLocaleString(), sunR: sun.r, angleCos: angleCos, sunY: sun.y };

  // 1点前の位置を取得
  pre1Dt = new Date(drawDt);
  pre1Dt.setHours(pre1Dt.getHours() - 6);
  mjd = AstroClass.mjd(pre1Dt, observer.timezone);
  t = AstroClass.t(mjd);
  pre1sun = new Sun(t);
  pre1moon = new Moon(t);
  pre1Cos = -Math.cos((pre1moon.y - pre1sun.y) * RAD);

  // 1点前と2点前の位置を更新
  pre2Cos = pre1Cos;
  pre1Dt = new Date(drawDt);
  pre1R = sun.r;
  pre1Cos = angleCos;
  pre1Y = sun.y;

  // 最終までの夜起点要素ループ
  // 開始点から6時間毎なのでdrawDtでインクリメントする。suntimeは不要
  for (dateIndex = 2; dateIndex <= rotateHours; dateIndex++) {
    drawDt.setHours(drawDt.getHours() + 6);

    // 月玉
    mjd = AstroClass.mjd(drawDt, observer.timezone);
    t = AstroClass.t(mjd);
    sun = new Sun(t);
    moon = new Moon(t);
    angleCos = -Math.cos((moon.y - sun.y) * RAD);
    moonBall[dateIndex] = { dtString: drawDt.toLocaleString(), sunR: sun.r, angleCos: angleCos, sunY: sun.y };

    // 2点前の離角余弦＜1点前の離角余弦＞現在の離角余弦（山）なら1点前を満月とする
    if (pre2Cos < pre1Cos && pre1Cos > angleCos) {
      // 要素数があらかじめ決められないのでPushで格納
      fullmoonBall.push({ dtString: pre1Dt.toLocaleString(), sunR: pre1R, angleCos: pre1Cos, sunY: pre1Y });
    }

    // 2点前の離角余弦＞1点前の離角余弦＜現在の離角余弦（谷）なら1点前を新月とする
    if (pre2Cos > pre1Cos && pre1Cos < angleCos) {
      // 要素数があらかじめ決められないのでPushで格納
      newmoonBall.push({ dtString: pre1Dt.toLocaleString(), sunR: pre1R, angleCos: pre1Cos, sunY: pre1Y });
    }

    // 1点前と2点前の位置を更新
    pre2Cos = pre1Cos;
    pre1Dt = new Date(drawDt);
    pre1R = sun.r;
    pre1Cos = angleCos;
    pre1Y = sun.y;
  }

  // ここから月SVG生成
  svg.groupId(`月`);

  svg.groupId(`月波`);
  // 1日目だけ描画色を変えるのでループ分け
  svg.groupId(`月波 ${moonBall[1].dtString}`);
  svg.circle(moonBall[1].sunR * SVG_AUR * (1 + moonBall[1].angleCos / 20), moonBall[1].sunY, svgSmallSize, SVG_LINE_WIDTH, GREEN_COLOR, `none`);
  svg.groupFooter();

  for (dateIndex = 2; dateIndex <= rotateHours; dateIndex++) {
    svg.groupId(`月波 ${moonBall[dateIndex].dtString}`);
    svg.circle(moonBall[dateIndex].sunR * SVG_AUR * (1 + moonBall[dateIndex].angleCos / 20), moonBall[dateIndex].sunY, svgSmallSize, SVG_LINE_WIDTH, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`満月玉`);
  // 要素数がわからないので0始まりの要素数でループ
  for (dateIndex = 0; dateIndex <= fullmoonBall.length - 1; dateIndex++) {
    svg.groupId(`満月玉 ${fullmoonBall[dateIndex].dtString}`);
    svg.circle(fullmoonBall[dateIndex].sunR * SVG_AUR * (1 + fullmoonBall[dateIndex].angleCos / 20), fullmoonBall[dateIndex].sunY, svgBigSize, SVG_LINE_WIDTH, strokeColor, fullmoonColor);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`新月玉`);
  // 要素数がわからないので0始まりの要素数でループ
  for (dateIndex = 0; dateIndex <= newmoonBall.length - 1; dateIndex++) {
    svg.groupId(`新月玉 ${newmoonBall[dateIndex].dtString}`);
    svg.circle(newmoonBall[dateIndex].sunR * SVG_AUR * (1 + newmoonBall[dateIndex].angleCos / 20), newmoonBall[dateIndex].sunY, svgBigSize, SVG_LINE_WIDTH, strokeColor, newmoonColor);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupFooter();
}
let defaultObject = {};
export default defaultObject;
</script>

