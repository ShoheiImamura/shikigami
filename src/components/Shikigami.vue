<script lang="ts">
import type { observerType } from './Observer.vue'
import { SvgClass } from './Svg.vue'
import type { svgType } from './Svg.vue'
import { AstroClass } from './Astro.vue'
import { SuntimeClass } from './Suntime.vue'
import type { SuntimeType } from './Suntime.vue'
import { planets } from './Planet.vue'
import type { Star, Satellite } from './Planet.vue'
const { Sun, Moon } = planets()

// 定数
const RAD = Math.PI / 180;
const SVG_LINE_WIDTH = 0.25;
const SVG_WIDTH = 1683.7795;
const SVG_HEIGHT = 2383.937;
const SVG_LEFT = 841.8896;
const SVG_TOP = 1191.9687;
const SVG_AUR = 424.0488; // 1AU = 424.0488px
const WHITE_COLOR = '#FFFFFF';
const BLACK_COLOR = '#000000';
const RED_COLOR = '#FF0000';
const GREEN_COLOR = '#33CC33';

let svg: svgType;

function downloadSVG() {
  svg.download();
}


type DaysData = {
  start: Date
  end: Date
  data: Array<{ date: number, value: number }>
}
// SHIKIGAMIメインルーチン
export const shikigami = (observer: observerType, flagDraw: {
  isDrawEarth: boolean,
  isDrawMoon: boolean,
  isDrawMercury: boolean,
  isDrawVenus: boolean,
  isDrawMars: boolean,
  isDrawJupiter: boolean,
  isDrawSaturn: boolean,
  isDrawUranus: boolean,
  isDrawNeptune: boolean,
  isDrawPluto: boolean,
  isDrawSunrise: boolean,
  isDrawSunset: boolean,
  isDrawDayArea: boolean,
  isDrawNightArea: boolean,
}, eachDaysData: DaysData, drawTime: 'noon' | 'central') => {
  let svgImage;
  let flagSunrise: boolean, flagSunset: boolean;
  let flagDay: boolean, flagNight: boolean;
  let flagDrawTime: boolean;
  const svgLineR = 583.54395;
  const svgSize = 1.723;

  svg = new SvgClass(observer.initDt, SVG_WIDTH, SVG_HEIGHT, SVG_LEFT, SVG_TOP);
  // 通日ラベルフォント
  svg.tag(`<style>.days{font-family: DroidSans, Droid Sans; font-size: 3.2px; color: #000000; stroke-width: 0.25; text-anchor: middle;}</style>`);
  svg.groupId(`ガイド基準`);
  svg.groupId(`中心点`);
  svg.circle(0, 0, svgSize, SVG_LINE_WIDTH, BLACK_COLOR, WHITE_COLOR,);
  svg.groupFooter();
  svg.groupId(`春分点方向線`);
  svg.line(0, 0, svgLineR, 0, SVG_LINE_WIDTH, RED_COLOR);
  svg.groupFooter();
  svg.groupFooter();

  // 描画フラグ設定
  flagSunrise = flagDraw.isDrawSunrise;
  flagSunset = flagDraw.isDrawSunset;
  flagDay = flagDraw.isDrawDayArea;
  flagNight = flagDraw.isDrawNightArea;

  // 描画基準時刻設定
  flagDrawTime = drawTime === 'noon';

  // 惑星描画
  if (flagDraw.isDrawEarth) { drawSun(observer, flagSunrise, flagSunset, flagDay, flagNight, flagDrawTime, eachDaysData); }
  if (flagDraw.isDrawMoon) { isDrawMoon(observer, flagDrawTime); }
  // if (flagDraw.isDrawMercury) { isDrawMercury(o, flagDrawTime); }
  // if (flagDraw.isDrawVenus) { isDrawVenus(o, flagDrawTime); }
  // if (flagDraw.isDrawMars) { isDrawMars(o, flagDrawTime); }
  // if (flagDraw.isDrawJupiter) { isDrawJupiter(o, flagDrawTime); }
  // if (flagDraw.isDrawSaturn) { isDrawSaturn(o, flagDrawTime); }
  // if (flagDraw.isDrawUranus) { isDrawUranus(o, flagDrawTime); }
  // if (flagDraw.isDrawNeptune) { isDrawNeptune(o, flagDrawTime); }
  // if (flagDraw.isDrawPluto) { isDrawPluto(o, flagDrawTime); }

  svg.groupId(`出力情報`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 210})">描画開始日：${observer.initDt.toLocaleDateString()}</text>`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 180})">描画場所：${observer.name} 経度 ${observer.longitude} / 緯度 ${observer.latitude} / タイムゾーン UTC+${observer.timezone}</text>`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 150})">描画基準時刻：${flagDrawTime ? '正午／正子' : '南中／北中'}</text>`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 100})">Generated by SHIKIGAMI 2.1.3 / Copyright(C)2021 Will System Design</text>`);
  svg.groupFooter();
  svg.end();

  svgImage = document.getElementById('svgImage') as HTMLElement;
  svgImage.innerHTML = svg.string;
}

const createSunbyDt = (date: Date, timezone: number) => {
  const mjd = AstroClass.mjd(date, timezone);
  const T = AstroClass.t(mjd);
  return new Sun(T);
}

// 描画関数
/** 地球（太陽） */
const drawSun = (observer: observerType, flagSunrise: boolean, flagSunset: boolean, flagDay: boolean, flagNight: boolean,
  flagDrawTime: boolean, eachDaysData: DaysData) => {
  const svgInR = 416.9622, svgOutR = 431.13545;
  const svgLineR = 583.54395;
  const svgDaysR = 433.22035;
  const svgSize = 1.723;
  const strokeColor = '#231815';
  const guideSunriseColor = '#FF9900', guideSunsetColor = '#CC6600';
  let startDt: Date, endDt: Date, rotateDays: number;
  let drawDt: Date;
  let suntime: SuntimeType;
  let sun: Star, sunrise: Star, sunset: Star;
  let sunDateLine: { suntimeDt: string, sunR: number, sunY: number }[] = [];
  let sunriseLine: { sunriseDt: Date, sunriseR: number, sunriseY: number }[] = [];
  let sunsetLine: { sunsetDt: Date, sunsetR: number, sunsetY: number }[] = [];
  let sunBall: { suntimeDt: string, sunR: number, sunY: number }[] = [];
  let sunNumber: { suntimeDt: string, offsetR: number, sunY: number, daysAngle: number }[] = [];
  let daysAngle: number, offsetR: number;
  let dateIndex: number;

  // 1 周の描画数を決める（日数）
  startDt = new Date(observer.initDt);
  endDt = new Date(observer.initDt);
  endDt.setFullYear(endDt.getFullYear() + 1);
  rotateDays = (endDt.getTime() - startDt.getTime()) / (1000 * 60 * 60 * 24);

  // 最初の夜起点要素
  drawDt = new Date(observer.initDt);
  suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);

  // 正子にするか北中にするか選ぶ
  sun = createSunbyDt((flagDrawTime) ? suntime.initDt : suntime.northDt, observer.timezone);
  // 日付線
  sunDateLine[1] = { suntimeDt: (flagDrawTime) ? suntime.initDt.toLocaleString() : suntime.northDt.toLocaleString(), sunR: sun.r, sunY: sun.y };

  // 日の出線
  sunrise = createSunbyDt(suntime.sunriseDt, observer.timezone);
  sunriseLine[1] = { sunriseDt: suntime.sunriseDt, sunriseR: sunrise.r, sunriseY: sunrise.y };

  // 日の入り線
  sunset = createSunbyDt(suntime.sunsetDt, observer.timezone);
  sunsetLine[1] = { sunsetDt: suntime.sunsetDt, sunsetR: sunset.r, sunsetY: sunset.y };

  // 最終までの夜起点要素ループ
  for (dateIndex = 2; dateIndex <= rotateDays; dateIndex++) {
    drawDt.setDate(drawDt.getDate() + 1);
    suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);

    // 日付線
    // 正子にするか北中にするか選ぶ
    sun = createSunbyDt(flagDrawTime ? suntime.initDt : suntime.northDt, observer.timezone);
    sunDateLine[dateIndex] = { suntimeDt: flagDrawTime ? suntime.initDt.toLocaleString() : suntime.northDt.toLocaleString(), sunR: sun.r, sunY: sun.y };

    // 日の出線
    sunrise = createSunbyDt(suntime.sunriseDt, observer.timezone);
    sunriseLine[dateIndex] = { sunriseDt: suntime.sunriseDt, sunriseR: sunrise.r, sunriseY: sunrise.y };

    // 日の入り線
    sunset = createSunbyDt(suntime.sunsetDt, observer.timezone);
    sunsetLine[dateIndex] = { sunsetDt: suntime.sunsetDt, sunsetR: sunset.r, sunsetY: sunset.y };
  }

  // 最初の昼起点要素
  drawDt = new Date(observer.initDt);
  suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);

  // 正午にするか南中にするか選ぶ
  sun = createSunbyDt(flagDrawTime ? suntime.noonDt : suntime.southDt, observer.timezone);
  // 地球玉
  // 正午にするか南中にするか選ぶ
  sunBall[1] = { suntimeDt: flagDrawTime ? suntime.noonDt.toLocaleString() : suntime.southDt.toLocaleString(), sunR: sun.r, sunY: sun.y };

  // 通日ラベル
  if (sun.y >= 180) {
    daysAngle = 270 - sun.y;
    offsetR = 2.25;
  } else {
    daysAngle = 90 - sun.y;
    offsetR = 0;
  }

  /** 正午にするか南中にするか選ぶ */
  sunNumber[1] = { suntimeDt: flagDrawTime ? suntime.noonDt.toLocaleString() : suntime.southDt.toLocaleString(), offsetR: offsetR, sunY: sun.y, daysAngle: daysAngle };

  /** 最終までの昼起点要素ループ */
  for (dateIndex = 2; dateIndex <= rotateDays; dateIndex++) {
    drawDt.setDate(drawDt.getDate() + 1);
    suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);

    // 正午にするか南中にするか選ぶ
    sun = createSunbyDt(flagDrawTime ? suntime.noonDt : suntime.southDt, observer.timezone);
    // 地球玉
    // 正午にするか南中にするか選ぶ
    sunBall[dateIndex] = { suntimeDt: flagDrawTime ? suntime.noonDt.toLocaleString() : suntime.southDt.toLocaleString(), sunR: sun.r, sunY: sun.y };

    // 通日ラベル
    if (sun.y >= 180) {
      daysAngle = 270 - sun.y;
      offsetR = 2.25;
    } else {
      daysAngle = 90 - sun.y;
      offsetR = 0;
    }
    // 正午にするか南中にするか選ぶ
    sunNumber[dateIndex] = { suntimeDt: flagDrawTime ? suntime.noonDt.toLocaleString() : suntime.southDt.toLocaleString(), offsetR: offsetR, sunY: sun.y, daysAngle: daysAngle };
  }

  // ここから地球SVG生成
  svg.groupId(`地球`);

  svg.groupId(`日付線`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`日付線' ${sunDateLine[1].suntimeDt}`);
  svg.line(SVG_AUR * sunDateLine[1].sunR, sunDateLine[1].sunY, svgLineR, sunDateLine[1].sunY, SVG_LINE_WIDTH, GREEN_COLOR);
  svg.groupFooter();

  for (dateIndex = 2; dateIndex <= rotateDays; dateIndex++) {
    svg.groupId(`日付線 ${sunDateLine[dateIndex].suntimeDt}`);
    svg.line(SVG_AUR * sunDateLine[dateIndex].sunR, sunDateLine[dateIndex].sunY, svgLineR, sunDateLine[dateIndex].sunY, SVG_LINE_WIDTH, strokeColor);
    svg.groupFooter();
  }
  svg.groupFooter();

  if (flagSunrise) {
    svg.groupId(`日の出線`);
    for (dateIndex = 1; dateIndex <= rotateDays; dateIndex++) {
      // ここでsuntime.sunriseDtを判定に使うので、文字列化はそのあとで
      if (flagSunrise && !isNaN(sunriseLine[dateIndex].sunriseDt.getTime())) {
        svg.groupId(`日の出線 ${sunriseLine[dateIndex].sunriseDt.toLocaleString()}`);
        svg.line(SVG_AUR * sunriseLine[dateIndex].sunriseR, sunriseLine[dateIndex].sunriseY, svgLineR, sunriseLine[dateIndex].sunriseY, SVG_LINE_WIDTH, guideSunriseColor);
        svg.groupFooter();
      }
    }
    svg.groupFooter();
  }

  if (flagSunset) {
    svg.groupId(`日の入り線`);
    for (dateIndex = 1; dateIndex <= rotateDays; dateIndex++) {
      if (!isNaN(sunsetLine[dateIndex].sunsetDt.getTime())) {
        // ここでsuntime.sunsetDtを判定に使うので、文字列化はそのあとで
        svg.groupId(`日の入り線 ${sunsetLine[dateIndex].sunsetDt.toLocaleString()}`);
        svg.line(SVG_AUR * sunsetLine[dateIndex].sunsetR, sunsetLine[dateIndex].sunsetY, svgLineR, sunsetLine[dateIndex].sunsetY, SVG_LINE_WIDTH, guideSunsetColor);
        svg.groupFooter();
      }
    }
    svg.groupFooter();
  }

  if (flagDay) {
    svg.groupId(`昼エリア`);

    for (dateIndex = 1; dateIndex <= rotateDays; dateIndex++) {
      if (!isNaN(sunriseLine[dateIndex].sunriseDt.getTime()) && !isNaN(sunsetLine[dateIndex].sunsetDt.getTime())) {
        // ここでsuntime.sunsetDtを判定に使うので、文字列化はそのあとで
        svg.groupId(`'昼エリア' + ${sunriseLine[dateIndex].sunriseDt.toLocaleString()} ${sunsetLine[dateIndex].sunsetDt.toLocaleString()}`);
        svg.area(SVG_AUR * sunriseLine[dateIndex].sunriseR, sunriseLine[dateIndex].sunriseY, SVG_AUR * sunsetLine[dateIndex].sunsetR, sunsetLine[dateIndex].sunsetY, svgLineR, SVG_LINE_WIDTH, guideSunriseColor, `none`);
        svg.groupFooter();
      }
    }
    svg.groupFooter();
  }

  if (flagNight) {
    svg.groupId(`夜エリア`);

    // 最終の夜エリアは開始日の日の出時間につなぐ
    for (dateIndex = 1; dateIndex <= rotateDays - 1; dateIndex++) {
      if (!isNaN(sunriseLine[dateIndex + 1].sunriseDt.getTime()) && !isNaN(sunsetLine[dateIndex].sunsetDt.getTime())) {
        // ここでsuntime.sunsetDtを判定に使うので、文字列化はそのあとで
        svg.groupId(`夜エリア ${sunsetLine[dateIndex].sunsetDt.toLocaleString()} ${sunriseLine[dateIndex + 1].sunriseDt.toLocaleString()}`);
        svg.area(SVG_AUR * sunriseLine[dateIndex + 1].sunriseR, sunriseLine[dateIndex + 1].sunriseY, SVG_AUR * sunsetLine[dateIndex].sunsetR, sunsetLine[dateIndex].sunsetY, svgLineR, SVG_LINE_WIDTH, guideSunsetColor, `none`);
        svg.groupFooter();
      }
    }

    if (!isNaN(sunsetLine[rotateDays].sunsetDt.getTime())) {
      // ここでsuntime.sunsetDtを判定に使うので、文字列化はそのあとで
      svg.groupId(`夜エリア ${sunsetLine[rotateDays].sunsetDt.toLocaleString()} 描画開始日の日の出日時`);
      svg.area(SVG_AUR * sunriseLine[1].sunriseR, sunriseLine[1].sunriseY, SVG_AUR * sunsetLine[rotateDays].sunsetR, sunsetLine[rotateDays].sunsetY, svgLineR, SVG_LINE_WIDTH, guideSunsetColor, `none`);
      svg.groupFooter();
    }
    svg.groupFooter();
  }

  // 追加グラフ
  if (true) {
    console.log(eachDaysData.data);
    svg.groupId(`円環棒グラフ`);
    for (dateIndex = 1; dateIndex <= rotateDays; dateIndex++) {

      const daysValue = eachDaysData.data[dateIndex] ? eachDaysData.data[dateIndex].value : 0
      console.log(daysValue);
      if (!isNaN(sunsetLine[dateIndex].sunsetDt.getTime())) {
        // ここでsuntime.sunsetDtを判定に使うので、文字列化はそのあとで
        svg.groupId(`円環棒グラフ ${sunsetLine[dateIndex].sunsetDt.toLocaleString()}`);
        svg.line(SVG_AUR * sunsetLine[dateIndex].sunsetR,
          sunsetLine[dateIndex].sunsetY,
          SVG_AUR * sunsetLine[dateIndex].sunsetR + daysValue,
          sunsetLine[dateIndex].sunsetY,
          6,
          'blue');
        svg.groupFooter();
      }
    }
    svg.groupFooter();
  }

  svg.groupId(`地球玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`地球玉 ${sunBall[1].suntimeDt}`);
  svg.circle(SVG_AUR * sunBall[1].sunR, sunBall[1].sunY, svgSize, SVG_LINE_WIDTH, GREEN_COLOR, `none`);
  svg.groupFooter();

  for (dateIndex = 2; dateIndex <= rotateDays; dateIndex++) {
    svg.groupId(`地球玉 ${sunBall[dateIndex].suntimeDt}`);
    svg.circle(SVG_AUR * sunBall[dateIndex].sunR, sunBall[dateIndex].sunY, svgSize, SVG_LINE_WIDTH, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`通日ラベル`);
  for (dateIndex = 1; dateIndex <= rotateDays; dateIndex++) {
    svg.groupId(`通日ラベル${('000' + dateIndex).slice(-3)} ${sunNumber[dateIndex].suntimeDt}`);
    svg.text('days', svgDaysR + sunNumber[dateIndex].offsetR, sunNumber[dateIndex].sunY, sunNumber[dateIndex].daysAngle, ('000' + dateIndex).slice(-3));
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`地球移動線`);
  for (dateIndex = 2; dateIndex <= rotateDays; dateIndex++) {
    svg.groupId(`地球移動線 ${sunBall[dateIndex].suntimeDt}`);
    svg.line(SVG_AUR * sunBall[dateIndex - 1].sunR, sunBall[dateIndex - 1].sunY, SVG_AUR * sunBall[dateIndex].sunR, sunBall[dateIndex].sunY, SVG_LINE_WIDTH, BLACK_COLOR);
    svg.groupFooter();
  }

  svg.groupId(`地球移動線 閉じる`);
  svg.line(SVG_AUR * sunBall[rotateDays].sunR, sunBall[rotateDays].sunY, SVG_AUR * sunBall[1].sunR, sunBall[1].sunY, SVG_LINE_WIDTH, BLACK_COLOR);
  svg.groupFooter();

  svg.groupFooter();

  svg.groupId(`地球近点軌道`);
  svg.circle(0, 0, svgInR, SVG_LINE_WIDTH, RED_COLOR, `none`);
  svg.groupFooter();

  svg.groupId(`地球遠点軌道`);
  svg.circle(0, 0, svgOutR, SVG_LINE_WIDTH, RED_COLOR, `none`);
  svg.groupFooter();

  svg.groupFooter();
}

/** 月 */
const isDrawMoon = (observer: observerType, flagDrawTime: boolean) => {
  const svgSmallSize = 0.4;
  const svgBigSize = 2.601;
  const strokeColor = '#231815';
  const fullmoonColor = '#FCC800', newmoonColor = '#3e3a39';
  let startDt: Date, endDt: Date, rotateHours: number;
  let drawDt: Date;
  let suntime: SuntimeType;
  let mjd: number, t: number;
  let sun: Star, moon: Satellite;
  let moonBall: { dtString: string, sunR: number, angleCos: number, sunY: number }[] = [];
  let fullmoonBall: { dtString: string, sunR: number, angleCos: number, sunY: number }[] = [];
  let newmoonBall: { dtString: string, sunR: number, angleCos: number, sunY: number }[] = [];
  let angleCos: number;
  let pre1sun: Star, pre1moon: Satellite, pre1Dt: Date, pre1Cos: number, pre1R: number, pre1Y: number, pre2Cos: number;
  let dateIndex: number;

  // 1周の描画数を決める（日数×6時間毎）
  startDt = new Date(observer.initDt);
  endDt = new Date(observer.initDt);
  endDt.setFullYear(endDt.getFullYear() + 1);
  rotateHours = (endDt.getTime() - startDt.getTime()) / (1000 * 60 * 60) / 6;

  // 最初の夜起点要素
  suntime = new SuntimeClass(observer.initDt, observer.longitude, observer.latitude, observer.timezone);
  // 正子にするか北中にするか選ぶ
  drawDt = new Date(flagDrawTime ? suntime.initDt : suntime.northDt);

  // 月波
  mjd = AstroClass.mjd(drawDt, observer.timezone);
  t = AstroClass.t(mjd);
  sun = new Sun(t);
  moon = new Moon(t);
  angleCos = -Math.cos((moon.y - sun.y) * RAD);
  moonBall[1] = { dtString: drawDt.toLocaleString(), sunR: sun.r, angleCos: angleCos, sunY: sun.y };

  // 1点前の位置を取得
  pre1Dt = new Date(drawDt);
  pre1Dt.setHours(pre1Dt.getHours() - 6);
  mjd = AstroClass.mjd(pre1Dt, observer.timezone);
  t = AstroClass.t(mjd);
  pre1sun = new Sun(t);
  pre1moon = new Moon(t);
  pre1Cos = -Math.cos((pre1moon.y - pre1sun.y) * RAD);

  // 1点前と2点前の位置を更新
  pre2Cos = pre1Cos;
  pre1Dt = new Date(drawDt);
  pre1R = sun.r;
  pre1Cos = angleCos;
  pre1Y = sun.y;

  // 最終までの夜起点要素ループ
  // 開始点から6時間毎なのでdrawDtでインクリメントする。suntimeは不要
  for (dateIndex = 2; dateIndex <= rotateHours; dateIndex++) {
    drawDt.setHours(drawDt.getHours() + 6);

    // 月玉
    mjd = AstroClass.mjd(drawDt, observer.timezone);
    t = AstroClass.t(mjd);
    sun = new Sun(t);
    moon = new Moon(t);
    angleCos = -Math.cos((moon.y - sun.y) * RAD);
    moonBall[dateIndex] = { dtString: drawDt.toLocaleString(), sunR: sun.r, angleCos: angleCos, sunY: sun.y };

    // 2点前の離角余弦＜1点前の離角余弦＞現在の離角余弦（山）なら1点前を満月とする
    if (pre2Cos < pre1Cos && pre1Cos > angleCos) {
      // 要素数があらかじめ決められないのでPushで格納
      fullmoonBall.push({ dtString: pre1Dt.toLocaleString(), sunR: pre1R, angleCos: pre1Cos, sunY: pre1Y });
    }

    // 2点前の離角余弦＞1点前の離角余弦＜現在の離角余弦（谷）なら1点前を新月とする
    if (pre2Cos > pre1Cos && pre1Cos < angleCos) {
      // 要素数があらかじめ決められないのでPushで格納
      newmoonBall.push({ dtString: pre1Dt.toLocaleString(), sunR: pre1R, angleCos: pre1Cos, sunY: pre1Y });
    }

    // 1点前と2点前の位置を更新
    pre2Cos = pre1Cos;
    pre1Dt = new Date(drawDt);
    pre1R = sun.r;
    pre1Cos = angleCos;
    pre1Y = sun.y;
  }

  // ここから月SVG生成
  svg.groupId(`月`);

  svg.groupId(`月波`);
  // 1日目だけ描画色を変えるのでループ分け
  svg.groupId(`月波 ${moonBall[1].dtString}`);
  svg.circle(moonBall[1].sunR * SVG_AUR * (1 + moonBall[1].angleCos / 20), moonBall[1].sunY, svgSmallSize, SVG_LINE_WIDTH, GREEN_COLOR, `none`);
  svg.groupFooter();

  for (dateIndex = 2; dateIndex <= rotateHours; dateIndex++) {
    svg.groupId(`月波 ${moonBall[dateIndex].dtString}`);
    svg.circle(moonBall[dateIndex].sunR * SVG_AUR * (1 + moonBall[dateIndex].angleCos / 20), moonBall[dateIndex].sunY, svgSmallSize, SVG_LINE_WIDTH, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`満月玉`);
  // 要素数がわからないので0始まりの要素数でループ
  for (dateIndex = 0; dateIndex <= fullmoonBall.length - 1; dateIndex++) {
    svg.groupId(`満月玉 ${fullmoonBall[dateIndex].dtString}`);
    svg.circle(fullmoonBall[dateIndex].sunR * SVG_AUR * (1 + fullmoonBall[dateIndex].angleCos / 20), fullmoonBall[dateIndex].sunY, svgBigSize, SVG_LINE_WIDTH, strokeColor, fullmoonColor);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`新月玉`);
  // 要素数がわからないので0始まりの要素数でループ
  for (dateIndex = 0; dateIndex <= newmoonBall.length - 1; dateIndex++) {
    svg.groupId(`新月玉 ${newmoonBall[dateIndex].dtString}`);
    svg.circle(newmoonBall[dateIndex].sunR * SVG_AUR * (1 + newmoonBall[dateIndex].angleCos / 20), newmoonBall[dateIndex].sunY, svgBigSize, SVG_LINE_WIDTH, strokeColor, newmoonColor);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupFooter();
}
const defaultText = '';
export default defaultText;
</script>

