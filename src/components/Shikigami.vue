<script lang="ts">
import type { observerType } from './Observer.vue'
import { SvgClass } from './Svg.vue'
import type { svgType } from './Svg.vue'
import { AstroClass } from './Astro.vue'
import { SuntimeClass } from './Suntime.vue'
import type { SuntimeType, timeBase } from './Suntime.vue'
import { Planet, planets } from './Planet.vue'
import type { Star, Satellite } from './Planet.vue'
import { drawEarth } from './shikigami/ShikigamiSun.vue'
import { drawMoon } from './shikigami/ShikigamiMoon.vue'
import { drawGraph } from './shikigami/ShikigamiGraph.vue'
const { Sun, Moon, Mercury, Venus, Mars, Jupiter, Saturn, Uranus, Neptune, Pluto } = planets()


// 定数
const RAD = Math.PI / 180;
const SVG_LINE_WIDTH = 0.25;
const SVG_WIDTH = 1683.7795;
const SVG_HEIGHT = 2383.937;
const SVG_LEFT = 841.8896;
const SVG_TOP = 1191.9687;
const SVG_AUR = 424.0488; // 1AU = 424.0488px
const WHITE_COLOR = '#FFFFFF';
const BLACK_COLOR = '#000000';
const RED_COLOR = '#FF0000';
const GREEN_COLOR = '#33CC33';

let svg: svgType;

function downloadSVG() {
  svg.download();
}


type DaysData = {
  start: Date
  end: Date
  data: Array<{ date: number, value: number }>
}
// SHIKIGAMIメインルーチン
export const shikigami = (observer: observerType, flagDraw: {
  isDrawEarth: boolean,
  isDrawMoon: boolean,
  isDrawMercury: boolean,
  isDrawVenus: boolean,
  isDrawMars: boolean,
  isDrawJupiter: boolean,
  isDrawSaturn: boolean,
  isDrawUranus: boolean,
  isDrawNeptune: boolean,
  isDrawPluto: boolean,
  isDrawSunrise: boolean,
  isDrawSunset: boolean,
  isDrawDayArea: boolean,
  isDrawNightArea: boolean,
}, eachDaysData: DaysData, drawTime: timeBase) => {
  let svgImage;
  let flagSunrise: boolean, flagSunset: boolean;
  let flagDay: boolean, flagNight: boolean;
  let flagDrawTime: boolean;
  const svgLineR = 583.54395;
  const svgSize = 1.723;

  svg = new SvgClass(observer.initDt, SVG_WIDTH, SVG_HEIGHT, SVG_LEFT, SVG_TOP);
  // 通日ラベルフォント
  svg.tag(`<style>.days{font-family: DroidSans, Droid Sans; font-size: 3.2px; color: #000000; stroke-width: 0.25; text-anchor: middle;}</style>`);
  svg.groupId(`ガイド基準`);
  svg.groupId(`中心点`);
  svg.circle(0, 0, svgSize, SVG_LINE_WIDTH, BLACK_COLOR, WHITE_COLOR,);
  svg.groupFooter();
  svg.groupId(`春分点方向線`);
  svg.line(0, 0, svgLineR, 0, SVG_LINE_WIDTH, RED_COLOR);
  svg.groupFooter();
  svg.groupFooter();

  // 描画フラグ設定
  flagSunrise = flagDraw.isDrawSunrise;
  flagSunset = flagDraw.isDrawSunset;
  flagDay = flagDraw.isDrawDayArea;
  flagNight = flagDraw.isDrawNightArea;

  // 描画基準時刻設定
  flagDrawTime = drawTime === 'clock';

  // 惑星描画
  if (flagDraw.isDrawEarth) { drawEarth(svg, observer, flagSunrise, flagSunset, flagDay, flagNight, drawTime,); }
  if (flagDraw.isDrawEarth) { drawGraph(svg, observer, drawTime, eachDaysData); }
  if (flagDraw.isDrawMoon) { drawMoon(svg, observer, drawTime); }
  if (flagDraw.isDrawMercury) { drawMercury(svg, observer, flagDrawTime); }
  if (flagDraw.isDrawVenus) { drawVenus(svg, observer, flagDrawTime); }
  if (flagDraw.isDrawMars) { drawMars(svg, observer, flagDrawTime); }
  if (flagDraw.isDrawJupiter) { drawJupiter(svg, observer, flagDrawTime); }
  if (flagDraw.isDrawSaturn) { drawSaturn(svg, observer, flagDrawTime); }
  if (flagDraw.isDrawUranus) { drawUranus(svg, observer, flagDrawTime); }
  if (flagDraw.isDrawNeptune) { drawNeptune(svg, observer, flagDrawTime); }
  if (flagDraw.isDrawPluto) { drawPluto(svg, observer, flagDrawTime); }

  svg.groupId(`出力情報`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 210})">描画開始日：${observer.initDt.toLocaleDateString()}</text>`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 180})">描画場所：${observer.name} 経度 ${observer.longitude} / 緯度 ${observer.latitude} / タイムゾーン UTC+${observer.timezone}</text>`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 150})">描画基準時刻：${flagDrawTime ? '正午／正子' : '南中／北中'}</text>`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 100})">Generated by SHIKIGAMI 2.1.3 / Copyright(C)2021 Will System Design</text>`);
  svg.groupFooter();
  svg.end();

  svgImage = document.getElementById('svgImage') as HTMLElement;
  svgImage.innerHTML = svg.string;
}

type PlanetPositions = {
  datetimeString: string,
  r: number,
  y: number,
}[];

// 水星
function drawMercury(svg: svgType, observer: observerType, flagDrawTime: boolean) {
  const svgInR = 130.3795, svgOutR = 197.8724;
  const svgSize = 0.69;
  const strokeColor = '#231815';
  const rotateDays = 88;
  let drawDt;
  let suntime;
  let mjd, t;
  let mercury;
  let mercuryBall: PlanetPositions = [];
  let compassY;
  let d;

  // 最初の要素
  drawDt = new Date(observer.initDt);
  suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
  } else {
    mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
  }
  t = AstroClass.t(mjd);
  mercury = new Mercury(t);

  // 水星玉
  compassY = mercury.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    // mercuryBall[1] = [suntime.noonDt.toLocaleString(), mercury.r, compassY];
    mercuryBall[1] = { datetimeString: suntime.noonDt.toLocaleString(), r: mercury.r, y: compassY };
  } else {
    // mercuryBall[1] = [suntime.southDt.toLocaleString(), mercury.r, compassY];
    mercuryBall[1] = { datetimeString: suntime.southDt.toLocaleString(), r: mercury.r, y: compassY };
  }

  // 最終までの要素ループ
  for (d = 2; d <= rotateDays; d++) {
    drawDt.setDate(drawDt.getDate() + 1);

    suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
    } else {
      mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
    }
    t = AstroClass.t(mjd);
    mercury = new Mercury(t);

    // 水星玉
    compassY = mercury.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mercuryBall[d] = { datetimeString: suntime.noonDt.toLocaleString(), r: mercury.r, y: compassY };
    } else {
      mercuryBall[d] = { datetimeString: suntime.southDt.toLocaleString(), r: mercury.r, y: compassY };
    }
  }

  // ここから水星SVG作成
  svg.groupId(`水星`);

  svg.groupId(`水星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`水星玉 ${mercuryBall[1].datetimeString}`);
  svg.circle(SVG_AUR * mercuryBall[1].r, mercuryBall[1].y, svgSize, SVG_LINE_WIDTH, GREEN_COLOR, `none`);
  svg.groupFooter();

  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`水星玉 ${mercuryBall[d].datetimeString}`);
    svg.circle(SVG_AUR * mercuryBall[d].r, mercuryBall[d].y, svgSize, SVG_LINE_WIDTH, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`水星移動線`);
  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`水星移動線 ${mercuryBall[d].datetimeString}`);
    svg.line(SVG_AUR * mercuryBall[d - 1].r, mercuryBall[d - 1].y, SVG_AUR * mercuryBall[d].r, mercuryBall[d].y, SVG_LINE_WIDTH, BLACK_COLOR);
    svg.groupFooter();
  }
  svg.groupId(`水星移動線 閉じる`);
  svg.line(SVG_AUR * mercuryBall[rotateDays].r, mercuryBall[rotateDays].y, SVG_AUR * mercuryBall[1].r, mercuryBall[1].y, SVG_LINE_WIDTH, BLACK_COLOR);
  svg.groupFooter();

  svg.groupFooter();

  svg.groupId(`水星近点軌道`);
  svg.circle(0, 0, svgInR, SVG_LINE_WIDTH, RED_COLOR, `none`);
  svg.groupFooter();
  svg.groupId(`水星遠点軌道`);
  svg.circle(0, 0, svgOutR, SVG_LINE_WIDTH, RED_COLOR, `none`);
  svg.groupFooter();

  svg.groupFooter();
}

// 金星
function drawVenus(svg: svgType, observer: observerType, flagDrawTime: boolean) {
  const svgInR = 304.611, svgOutR = 308.7921;
  const svgSize = 1.72;
  const strokeColor = '#231815';
  const rotateDays = 225;
  let drawDt;
  let suntime;
  let mjd, t;
  let venus;
  let venusBall: PlanetPositions = [];
  let compassY
  let d;

  // 最初の要素
  drawDt = new Date(observer.initDt);
  suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
  } else {
    mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
  }
  t = AstroClass.t(mjd);
  venus = new Venus(t);

  // 金星玉
  compassY = venus.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    venusBall[1] = { datetimeString: suntime.noonDt.toLocaleString(), r: venus.r, y: compassY };
  } else {
    venusBall[1] = { datetimeString: suntime.southDt.toLocaleString(), r: venus.r, y: compassY };
  }

  // 最終までの要素ループ
  for (d = 2; d <= rotateDays; d++) {
    drawDt.setDate(drawDt.getDate() + 1);
    suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
    } else {
      mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
    }
    t = AstroClass.t(mjd);
    venus = new Venus(t);

    // 金星玉
    compassY = venus.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      venusBall[d] = { datetimeString: suntime.noonDt.toLocaleString(), r: venus.r, y: compassY };
    } else {
      venusBall[d] = { datetimeString: suntime.southDt.toLocaleString(), r: venus.r, y: compassY };
    }
  }

  // ここから金星SVG作成
  svg.groupId(`金星`);

  svg.groupId(`金星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`金星玉 ${venusBall[1].datetimeString}`);
  svg.circle(SVG_AUR * venusBall[1].r, venusBall[1].y, svgSize, SVG_LINE_WIDTH, GREEN_COLOR, `none`);
  svg.groupFooter();

  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`金星玉 ${venusBall[d].datetimeString}`);
    svg.circle(SVG_AUR * venusBall[d].r, venusBall[d].y, svgSize, SVG_LINE_WIDTH, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`金星移動線`);
  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`金星移動線 ${venusBall[d].datetimeString}`);
    svg.line(SVG_AUR * venusBall[d - 1].r, venusBall[d - 1].y, SVG_AUR * venusBall[d].r, venusBall[d].y, SVG_LINE_WIDTH, BLACK_COLOR);
    svg.groupFooter();
  }
  svg.groupId(`金星移動線 閉じる`);
  svg.line(SVG_AUR * venusBall[rotateDays].r, venusBall[rotateDays].y, SVG_AUR * venusBall[1].r, venusBall[1].y, SVG_LINE_WIDTH, BLACK_COLOR);
  svg.groupFooter();

  svg.groupFooter();

  svg.groupId(`金星近点軌道`);
  svg.circle(0, 0, svgInR, SVG_LINE_WIDTH, RED_COLOR, `none`);
  svg.groupFooter();
  svg.groupId(`金星遠点軌道`);
  svg.circle(0, 0, svgOutR, SVG_LINE_WIDTH, RED_COLOR, `none`);
  svg.groupFooter();

  svg.groupFooter();
}



// 火星
function drawMars(svg: svgType, observer: observerType, flagDrawTime: boolean) {
  const svgInR = 585.71316, svgOutR = 706.40593;
  const svgSize = 0.96;
  const strokeColor = '#333333';
  const rotateDays = 687;
  let drawDt;
  let suntime;
  let mjd, t;
  let mars;
  let marsBall: PlanetPositions = [];
  let compassY;
  let d;

  // 最初の要素
  drawDt = new Date(observer.initDt);
  suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
  } else {
    mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
  }
  t = AstroClass.t(mjd);
  mars = new Mars(t);

  // 火星玉
  compassY = mars.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }

  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    marsBall[1] = { datetimeString: suntime.noonDt.toLocaleString(), r: mars.r, y: compassY };
  } else {
    marsBall[1] = { datetimeString: suntime.southDt.toLocaleString(), r: mars.r, y: compassY };
  }

  // 最終までの要素ループ
  for (d = 2; d <= rotateDays; d++) {
    drawDt.setDate(drawDt.getDate() + 1);
    suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
    } else {
      mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
    }
    t = AstroClass.t(mjd);
    mars = new Mars(t);

    // 火星玉
    compassY = mars.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      marsBall[d] = { datetimeString: suntime.noonDt.toLocaleString(), r: mars.r, y: compassY };
    } else {
      marsBall[d] = { datetimeString: suntime.southDt.toLocaleString(), r: mars.r, y: compassY };
    }
  }

  // ここから火星SVG作成
  svg.groupId(`火星`);

  svg.groupId(`火星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`火星玉 ${marsBall[1].datetimeString}`);
  svg.circle(SVG_AUR * marsBall[1].r, marsBall[1].y, svgSize, SVG_LINE_WIDTH, GREEN_COLOR, `none`);
  svg.groupFooter();

  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`火星玉 ${marsBall[d].datetimeString}`);
    svg.circle(SVG_AUR * marsBall[d].r, marsBall[d].y, svgSize, SVG_LINE_WIDTH, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`火星移動線`);
  for (d = 2; d <= rotateDays; d++) {
    svg.groupId(`火星移動線 ${marsBall[d].datetimeString}`);
    svg.line(SVG_AUR * marsBall[d - 1].r, marsBall[d - 1].y, SVG_AUR * marsBall[d].r, marsBall[d].y, SVG_LINE_WIDTH, BLACK_COLOR);
    svg.groupFooter();
  }
  svg.groupId(`火星移動線 閉じる`);
  svg.line(SVG_AUR * marsBall[rotateDays].r, marsBall[rotateDays].y, SVG_AUR * marsBall[1].r, marsBall[1].y, SVG_LINE_WIDTH, BLACK_COLOR);
  svg.groupFooter();

  svg.groupFooter();

  svg.groupId(`火星近点軌道`);
  svg.circle(0, 0, svgInR, SVG_LINE_WIDTH, RED_COLOR, `none`);
  svg.groupFooter();
  svg.groupId(`火星遠点軌道`);
  svg.circle(0, 0, svgOutR, SVG_LINE_WIDTH, RED_COLOR, `none`);
  svg.groupFooter();

  svg.groupFooter();
}

// 木星
function drawJupiter(svg: svgType, observer: observerType, flagDrawTime: boolean) {
  const svgR = 730.001;
  const svgSmallSize = 1.0023;
  const svgBigSize = 20.126;
  const strokeColor = '#333333';
  const rotateMonths = 12;
  const rotateYears = 12;
  let drawDt;
  let suntime;
  let mjd, t;
  let jupiter;
  let jupiterSmallBall: PlanetPositions = [], jupiterBigBall: PlanetPositions = [];
  let compassY;
  let d;

  // 最初の要素
  drawDt = new Date(observer.initDt);
  suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
  } else {
    mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
  }
  t = AstroClass.t(mjd);
  jupiter = new Jupiter(t);

  // 木星玉・大
  compassY = jupiter.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }
  // 動径は平均軌道半径で固定
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    jupiterBigBall[1] = { datetimeString: suntime.noonDt.toLocaleString(), r: svgR, y: compassY };
  } else {
    jupiterBigBall[1] = { datetimeString: suntime.southDt.toLocaleString(), r: svgR, y: compassY };
  }

  // 1年後までの要素ループ
  // 翌月1日から毎月1日を描画
  drawDt.setDate(1);

  for (d = 1; d <= rotateMonths; d++) {
    drawDt.setMonth(drawDt.getMonth() + 1);
    suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
    } else {
      mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
    }
    t = AstroClass.t(mjd);
    jupiter = new Jupiter(t);

    // 木星玉・小
    compassY = jupiter.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }

    // 動径は平均軌道半径で固定
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      jupiterSmallBall[d] = { datetimeString: suntime.noonDt.toLocaleString(), r: svgR, y: compassY };
    } else {
      jupiterSmallBall[d] = { datetimeString: suntime.southDt.toLocaleString(), r: svgR, y: compassY };
    }
  }

  // 1年後から最終までの要素ループ
  drawDt = new Date(observer.initDt);
  // 翌年の1日前から毎年1日前を描画
  drawDt.setDate(drawDt.getDate() - 1);

  for (d = 2; d <= rotateYears; d++) {
    drawDt.setFullYear(drawDt.getFullYear() + 1);
    suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
    } else {
      mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
    }
    t = AstroClass.t(mjd);
    jupiter = new Jupiter(t);

    // 木星玉・大
    compassY = jupiter.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 動径は平均軌道半径で固定
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      jupiterBigBall[d] = { datetimeString: suntime.noonDt.toLocaleString(), r: svgR, y: compassY };
    } else {
      jupiterBigBall[d] = { datetimeString: suntime.southDt.toLocaleString(), r: svgR, y: compassY };
    }
  }

  // ここから木星SVG作成
  svg.groupId(`木星`);

  svg.groupId(`木星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`木星玉・大 ${jupiterBigBall[1].datetimeString}`);
  svg.circle(jupiterBigBall[1].r, jupiterBigBall[1].y, svgBigSize, SVG_LINE_WIDTH, GREEN_COLOR, `none`);
  svg.groupFooter();

  for (d = 1; d <= rotateMonths; d++) {
    svg.groupId(`木星玉・小 ${jupiterSmallBall[d].datetimeString}`);
    svg.circle(jupiterSmallBall[d].r, jupiterSmallBall[d].y, svgSmallSize, SVG_LINE_WIDTH, strokeColor, `none`);
    svg.groupFooter();
  }

  for (d = 2; d <= rotateYears; d++) {
    svg.groupId(`木星玉・大 ${jupiterBigBall[d].datetimeString}`);
    svg.circle(jupiterBigBall[d].r, jupiterBigBall[d].y, svgBigSize, SVG_LINE_WIDTH, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`木星軌道線`);
  svg.groupId(`木星移動線 ${jupiterSmallBall[1].datetimeString}`);
  svg.arc(jupiterBigBall[1].r, jupiterBigBall[1].y, jupiterSmallBall[1].r, jupiterSmallBall[1].y, svgR, SVG_LINE_WIDTH, RED_COLOR, 'none');
  svg.groupFooter();

  for (d = 2; d <= rotateMonths; d++) {
    svg.groupId(`木星移動線 ${jupiterSmallBall[d].datetimeString}`);
    svg.arc(jupiterSmallBall[d - 1].r, jupiterSmallBall[d - 1].y, jupiterSmallBall[d].r, jupiterSmallBall[d].y, svgR, SVG_LINE_WIDTH, RED_COLOR, 'none');
    svg.groupFooter();
  }

  svg.groupId(`木星移動線 ${jupiterBigBall[2].datetimeString}`);
  svg.arc(jupiterSmallBall[rotateMonths].r, jupiterSmallBall[rotateMonths].y, jupiterBigBall[2].r, jupiterBigBall[2].y, svgR, SVG_LINE_WIDTH, RED_COLOR, 'none');
  svg.groupFooter();

  for (d = 3; d <= rotateYears; d++) {
    svg.groupId(`木星移動線 ${jupiterBigBall[d].datetimeString}`);
    svg.arc(jupiterBigBall[d - 1].r, jupiterBigBall[d - 1].y, jupiterBigBall[d].r, jupiterBigBall[d].y, svgR, SVG_LINE_WIDTH, RED_COLOR, 'none');
    svg.groupFooter();
  }

  svg.groupId(`木星移動線 閉じる`);
  svg.arc(jupiterBigBall[rotateYears].r, jupiterBigBall[rotateYears].y, jupiterBigBall[1].r, jupiterBigBall[1].y, svgR, SVG_LINE_WIDTH, RED_COLOR, 'none');
  svg.groupFooter();
  svg.groupFooter();

  svg.groupFooter();
}

// 土星
function drawSaturn(svg: svgType, observer: observerType, flagDrawTime: boolean) {
  const svgR = 766.667;
  const svgSmallSize = 1.0023;
  const svgBigSize = 17.0088;
  const strokeColor = '#333333';
  const rotateMonths = 12;
  const rotateYears = 30;
  let drawDt;
  let suntime;
  let mjd, t;
  let saturn;
  let saturnSmallBall: PlanetPositions = [], saturnBigBall: PlanetPositions = [];
  let compassY;
  let d;

  // 最初の要素
  drawDt = new Date(observer.initDt);
  suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
  } else {
    mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
  }
  t = AstroClass.t(mjd);
  saturn = new Saturn(t);

  // 土星玉・大
  compassY = saturn.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }
  // 動径は平均軌道半径で固定
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    saturnBigBall[1] = { datetimeString: suntime.noonDt.toLocaleString(), r: svgR, y: compassY };
  } else {
    saturnBigBall[1] = { datetimeString: suntime.southDt.toLocaleString(), r: svgR, y: compassY };
  }

  // 1年後までの要素ループ
  // 翌月1日から毎月1日を描画
  drawDt.setDate(1);

  for (d = 1; d <= rotateMonths; d++) {
    drawDt.setMonth(drawDt.getMonth() + 1);
    suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
    } else {
      mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
    }
    t = AstroClass.t(mjd);
    saturn = new Saturn(t);

    // 土星玉・小
    compassY = saturn.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 動径は平均軌道半径で固定
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      saturnSmallBall[d] = { datetimeString: suntime.noonDt.toLocaleString(), r: svgR, y: compassY };
    } else {
      saturnSmallBall[d] = { datetimeString: suntime.southDt.toLocaleString(), r: svgR, y: compassY };
    }
  }

  // 1年後から最終までの要素ループ
  drawDt = new Date(observer.initDt);
  // 翌年の1日前から毎年1日前を描画
  drawDt.setDate(drawDt.getDate() - 1);

  for (d = 2; d <= rotateYears; d++) {
    drawDt.setFullYear(drawDt.getFullYear() + 1);
    suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
    } else {
      mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
    }
    t = AstroClass.t(mjd);
    saturn = new Saturn(t);

    // 土星玉・大
    compassY = saturn.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 動径は平均軌道半径で固定
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      saturnBigBall[d] = { datetimeString: suntime.noonDt.toLocaleString(), r: svgR, y: compassY };
    } else {
      saturnBigBall[d] = { datetimeString: suntime.southDt.toLocaleString(), r: svgR, y: compassY };
    }
  }

  // ここから土星SVG作成
  svg.groupId(`土星`);

  svg.groupId(`土星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`土星玉・大 ${saturnBigBall[1].datetimeString}`);
  svg.circle(saturnBigBall[1].r, saturnBigBall[1].y, svgBigSize, SVG_LINE_WIDTH, GREEN_COLOR, `none`);
  svg.groupFooter();

  for (d = 1; d <= rotateMonths; d++) {
    svg.groupId(`土星玉・小 ${saturnSmallBall[d].datetimeString}`);
    svg.circle(saturnSmallBall[d].r, saturnSmallBall[d].y, svgSmallSize, SVG_LINE_WIDTH, strokeColor, `none`);
    svg.groupFooter();
  }

  for (d = 2; d <= rotateYears; d++) {
    svg.groupId(`土星玉・大 ${saturnBigBall[d].datetimeString}`);
    svg.circle(saturnBigBall[d].r, saturnBigBall[d].y, svgBigSize, SVG_LINE_WIDTH, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`土星軌道線`);
  svg.groupId(`土星移動線 ${saturnSmallBall[1].datetimeString}`);
  svg.arc(saturnBigBall[1].r, saturnBigBall[1].y, saturnSmallBall[1].r, saturnSmallBall[1].y, svgR, SVG_LINE_WIDTH, RED_COLOR, 'none');
  svg.groupFooter();

  for (d = 2; d <= rotateMonths; d++) {
    svg.groupId(`土星移動線 ${saturnSmallBall[d].datetimeString}`);
    svg.arc(saturnSmallBall[d - 1].r, saturnSmallBall[d - 1].y, saturnSmallBall[d].r, saturnSmallBall[d].y, svgR, SVG_LINE_WIDTH, RED_COLOR, 'none');
    svg.groupFooter();
  }

  svg.groupId(`土星移動線 ${saturnBigBall[2].datetimeString}`);
  svg.arc(saturnSmallBall[rotateMonths].r, saturnSmallBall[rotateMonths].y, saturnBigBall[2].r, saturnBigBall[2].y, svgR, SVG_LINE_WIDTH, RED_COLOR, 'none');
  svg.groupFooter();

  for (d = 3; d <= rotateYears; d++) {
    svg.groupId(`土星移動線 ${saturnBigBall[d].datetimeString}`);
    svg.arc(saturnBigBall[d - 1].r, saturnBigBall[d - 1].y, saturnBigBall[d].r, saturnBigBall[d].y, svgR, SVG_LINE_WIDTH, RED_COLOR, 'none');
    svg.groupFooter();
  }

  svg.groupId(`土星移動線 閉じる`);
  svg.arc(saturnBigBall[rotateYears].r, saturnBigBall[rotateYears].y, saturnBigBall[1].r, saturnBigBall[1].y, svgR, SVG_LINE_WIDTH, RED_COLOR, 'none');
  svg.groupFooter();
  svg.groupFooter();

  svg.groupFooter();
}

// 天王星
function drawUranus(svg: svgType, observer: observerType, flagDrawTime: boolean) {
  const svgR = 792.667;
  const svgSize = 7.3696;
  const strokeColor = '#333333';
  const rotateYears = 86;
  let drawDt;
  let suntime;
  let mjd, t;
  let uranus;
  let uranusBall: PlanetPositions = [];
  let compassY
  let d;

  // 最初の要素
  drawDt = new Date(observer.initDt);
  suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
  } else {
    mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
  }
  t = AstroClass.t(mjd);
  uranus = new Uranus(t);

  // 天王星玉
  compassY = uranus.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }
  // 動径は平均軌道半径で固定
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    uranusBall[1] = { datetimeString: suntime.noonDt.toLocaleString(), r: svgR, y: compassY };
  } else {
    uranusBall[1] = { datetimeString: suntime.southDt.toLocaleString(), r: svgR, y: compassY };
  }

  // 最終までの要素ループ	
  // 翌年の1日前から毎年1日前を描画
  drawDt.setDate(drawDt.getDate() - 1);

  for (d = 2; d <= rotateYears; d++) {
    drawDt.setFullYear(drawDt.getFullYear() + 1);
    suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
    } else {
      mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
    }
    t = AstroClass.t(mjd);
    uranus = new Uranus(t);

    // 天王星玉
    compassY = uranus.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 動径は平均軌道半径で固定
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      uranusBall[d] = { datetimeString: suntime.noonDt.toLocaleString(), r: svgR, y: compassY };
    } else {
      uranusBall[d] = { datetimeString: suntime.southDt.toLocaleString(), r: svgR, y: compassY };
    }
  }

  // ここから天王星SVG作成
  svg.groupId(`天王星`);

  svg.groupId(`天王星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`天王星玉 ${uranusBall[1].datetimeString}`);
  svg.circle(uranusBall[1].r, uranusBall[1].y, svgSize, SVG_LINE_WIDTH, GREEN_COLOR, `none`);
  svg.groupFooter();

  for (d = 2; d <= rotateYears; d++) {
    svg.groupId(`天王星玉 ${uranusBall[d].datetimeString}`);
    svg.circle(uranusBall[d].r, uranusBall[d].y, svgSize, SVG_LINE_WIDTH, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`天王星移動線`);
  for (d = 2; d <= rotateYears; d++) {
    svg.groupId(`天王星移動線 ${uranusBall[d].datetimeString}`);
    svg.arc(uranusBall[d - 1].r, uranusBall[d - 1].y, uranusBall[d].r, uranusBall[d].y, svgR, SVG_LINE_WIDTH, RED_COLOR, 'none');
    svg.groupFooter();
  }
  svg.groupId(`天王星移動線 閉じる`);
  svg.arc(uranusBall[rotateYears].r, uranusBall[rotateYears].y, uranusBall[1].r, uranusBall[1].y, svgR, SVG_LINE_WIDTH, RED_COLOR, 'none');
  svg.groupFooter();
  svg.groupFooter();

  svg.groupFooter();
}

// 海王星
function drawNeptune(svg: svgType, observer: observerType, flagDrawTime: boolean) {
  const svgR = 806.001;
  const svgSize = 7.0859;
  const strokeColor = '#333333';
  const rotateYears = 164;
  let drawDt;
  let suntime;
  let mjd, t;
  let neptune;
  let neptuneBall: PlanetPositions = [];
  let compassY;
  let d;

  // 最初の要素
  drawDt = new Date(observer.initDt);
  suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
  } else {
    mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
  }
  t = AstroClass.t(mjd);
  neptune = new Neptune(t);

  // 海王星玉
  compassY = neptune.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }
  // 動径は平均軌道半径で固定
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    neptuneBall[1] = { datetimeString: suntime.noonDt.toLocaleString(), r: svgR, y: compassY };
  } else {
    neptuneBall[1] = { datetimeString: suntime.southDt.toLocaleString(), r: svgR, y: compassY };
  }

  // 最終までの要素ループ	
  // 翌年の1日前から毎年1日前を描画
  drawDt.setDate(drawDt.getDate() - 1);

  for (d = 2; d <= rotateYears; d++) {
    drawDt.setFullYear(drawDt.getFullYear() + 1);
    suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
    } else {
      mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
    }
    t = AstroClass.t(mjd);
    neptune = new Neptune(t);

    // 海王星玉
    compassY = neptune.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 動径は平均軌道半径で固定
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      neptuneBall[d] = { datetimeString: suntime.noonDt.toLocaleString(), r: svgR, y: compassY };
    } else {
      neptuneBall[d] = { datetimeString: suntime.southDt.toLocaleString(), r: svgR, y: compassY };
    }
  }

  // ここから海王星SVG作成
  svg.groupId(`海王星`);

  svg.groupId(`海王星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`海王星玉 ${neptuneBall[1].datetimeString}`);
  svg.circle(neptuneBall[1].r, neptuneBall[1].y, svgSize, SVG_LINE_WIDTH, GREEN_COLOR, `none`);
  svg.groupFooter();

  for (d = 2; d <= rotateYears; d++) {
    svg.groupId(`海王星玉 ${neptuneBall[d].datetimeString}`);
    svg.circle(neptuneBall[d].r, neptuneBall[d].y, svgSize, SVG_LINE_WIDTH, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`海王星移動線`);
  for (d = 2; d <= rotateYears; d++) {
    svg.groupId(`海王星移動線 ${neptuneBall[d].datetimeString}`);
    svg.arc(neptuneBall[d - 1].r, neptuneBall[d - 1].y, neptuneBall[d].r, neptuneBall[d].y, svgR, SVG_LINE_WIDTH, RED_COLOR, 'none');
    svg.groupFooter();
  }
  svg.groupId(`海王星移動線 閉じる`);
  svg.arc(neptuneBall[rotateYears].r, neptuneBall[rotateYears].y, neptuneBall[1].r, neptuneBall[1].y, svgR, SVG_LINE_WIDTH, RED_COLOR, 'none');
  svg.groupFooter();
  svg.groupFooter();

  svg.groupFooter();
}

// 冥王星
function drawPluto(svg: svgType, observer: observerType, flagDrawTime: boolean) {
  const svgR = 818.667;
  const svgSize = 0.2832;
  const strokeColor = '#333333';
  const rotateYears = 219;
  let drawDt;
  let suntime;
  let mjd, t;
  let pluto;
  let plutoBall: PlanetPositions = [];
  let compassY;
  let d;

  // 最初の要素
  drawDt = new Date(observer.initDt);
  suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
  } else {
    mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
  }
  t = AstroClass.t(mjd);
  pluto = new Pluto(t);

  // 冥王星玉
  compassY = pluto.y + 180;
  if (compassY >= 360) {
    compassY -= 360;
  }
  // 動径は平均軌道半径で固定
  // 正午にするか南中にするか選ぶ
  if (flagDrawTime) {
    plutoBall[1] = { datetimeString: suntime.noonDt.toLocaleString(), r: svgR, y: compassY };
  } else {
    plutoBall[1] = { datetimeString: suntime.southDt.toLocaleString(), r: svgR, y: compassY };
  }

  // 最終までの要素ループ	
  // 翌年の1日前から毎年1日前を描画
  drawDt.setDate(drawDt.getDate() - 1);

  for (d = 2; d <= rotateYears; d++) {
    drawDt.setFullYear(drawDt.getFullYear() + 1);
    suntime = new SuntimeClass(drawDt, observer.longitude, observer.latitude, observer.timezone);
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      mjd = AstroClass.mjd(suntime.noonDt, observer.timezone);
    } else {
      mjd = AstroClass.mjd(suntime.southDt, observer.timezone);
    }
    t = AstroClass.t(mjd);
    pluto = new Pluto(t);

    // 冥王星玉
    compassY = pluto.y + 180;
    if (compassY >= 360) {
      compassY -= 360;
    }
    // 動径は平均軌道半径で固定
    // 正午にするか南中にするか選ぶ
    if (flagDrawTime) {
      plutoBall[d] = { datetimeString: suntime.noonDt.toLocaleString(), r: svgR, y: compassY };
    } else {
      plutoBall[d] = { datetimeString: suntime.southDt.toLocaleString(), r: svgR, y: compassY };
    }
  }

  // ここから冥王星SVG作成
  svg.groupId(`冥王星`);

  svg.groupId(`冥王星玉`);
  // 最初だけ描画色を変えるのでループ分け
  svg.groupId(`冥王星玉 ${plutoBall[1].datetimeString}`);
  svg.circle(plutoBall[1].r, plutoBall[1].y, svgSize, SVG_LINE_WIDTH, GREEN_COLOR, `none`);
  svg.groupFooter();

  for (d = 2; d <= rotateYears; d++) {
    svg.groupId(`冥王星玉 ${plutoBall[d].datetimeString}`);
    svg.circle(plutoBall[d].r, plutoBall[d].y, svgSize, SVG_LINE_WIDTH, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`冥王星移動線`);
  for (d = 2; d <= rotateYears; d++) {
    svg.groupId(`冥王星移動線 ${plutoBall[d].datetimeString}`);
    svg.arc(plutoBall[d - 1].r, plutoBall[d - 1].y, plutoBall[d].r, plutoBall[d].y, svgR, SVG_LINE_WIDTH, RED_COLOR, 'none');
    svg.groupFooter();
  }
  svg.groupId(`冥王星移動線 閉じる`);
  svg.arc(plutoBall[rotateYears].r, plutoBall[rotateYears].y, plutoBall[1].r, plutoBall[1].y, svgR, SVG_LINE_WIDTH, RED_COLOR, 'none');
  svg.groupFooter();
  svg.groupFooter();

  svg.groupFooter();
}

let defaultObject = {};
export default defaultObject;
</script>

