<script lang="ts">
import type { observerType } from './Observer.vue'
import { SvgClass } from './Svg.vue'
import type { svgType } from './Svg.vue'
import { AstroClass } from './Astro.vue'
import { SuntimeClass } from './Suntime.vue'
import type { SuntimeType, timeBase } from './Suntime.vue'
import { planets } from './Planet.vue'
import type { Star, Satellite } from './Planet.vue'
import { drawSun } from './svg/SvgSun.vue'
const { Sun, Moon } = planets()


// 定数
const RAD = Math.PI / 180;
const SVG_LINE_WIDTH = 0.25;
const SVG_WIDTH = 1683.7795;
const SVG_HEIGHT = 2383.937;
const SVG_LEFT = 841.8896;
const SVG_TOP = 1191.9687;
const SVG_AUR = 424.0488; // 1AU = 424.0488px
const WHITE_COLOR = '#FFFFFF';
const BLACK_COLOR = '#000000';
const RED_COLOR = '#FF0000';
const GREEN_COLOR = '#33CC33';

let svg: svgType;

function downloadSVG() {
  svg.download();
}


type DaysData = {
  start: Date
  end: Date
  data: Array<{ date: number, value: number }>
}
// SHIKIGAMIメインルーチン
export const shikigami = (observer: observerType, flagDraw: {
  isDrawEarth: boolean,
  isDrawMoon: boolean,
  isDrawMercury: boolean,
  isDrawVenus: boolean,
  isDrawMars: boolean,
  isDrawJupiter: boolean,
  isDrawSaturn: boolean,
  isDrawUranus: boolean,
  isDrawNeptune: boolean,
  isDrawPluto: boolean,
  isDrawSunrise: boolean,
  isDrawSunset: boolean,
  isDrawDayArea: boolean,
  isDrawNightArea: boolean,
}, eachDaysData: DaysData, drawTime: timeBase) => {
  let svgImage;
  let flagSunrise: boolean, flagSunset: boolean;
  let flagDay: boolean, flagNight: boolean;
  let flagDrawTime: boolean;
  const svgLineR = 583.54395;
  const svgSize = 1.723;

  svg = new SvgClass(observer.initDt, SVG_WIDTH, SVG_HEIGHT, SVG_LEFT, SVG_TOP);
  // 通日ラベルフォント
  svg.tag(`<style>.days{font-family: DroidSans, Droid Sans; font-size: 3.2px; color: #000000; stroke-width: 0.25; text-anchor: middle;}</style>`);
  svg.groupId(`ガイド基準`);
  svg.groupId(`中心点`);
  svg.circle(0, 0, svgSize, SVG_LINE_WIDTH, BLACK_COLOR, WHITE_COLOR,);
  svg.groupFooter();
  svg.groupId(`春分点方向線`);
  svg.line(0, 0, svgLineR, 0, SVG_LINE_WIDTH, RED_COLOR);
  svg.groupFooter();
  svg.groupFooter();

  // 描画フラグ設定
  flagSunrise = flagDraw.isDrawSunrise;
  flagSunset = flagDraw.isDrawSunset;
  flagDay = flagDraw.isDrawDayArea;
  flagNight = flagDraw.isDrawNightArea;

  // 描画基準時刻設定
  flagDrawTime = drawTime === 'clock';

  // 惑星描画
  if (flagDraw.isDrawEarth) { drawSun(svg, observer, flagSunrise, flagSunset, flagDay, flagNight, drawTime, eachDaysData); }
  if (flagDraw.isDrawMoon) { isDrawMoon(observer, flagDrawTime); }
  // if (flagDraw.isDrawMercury) { isDrawMercury(o, flagDrawTime); }
  // if (flagDraw.isDrawVenus) { isDrawVenus(o, flagDrawTime); }
  // if (flagDraw.isDrawMars) { isDrawMars(o, flagDrawTime); }
  // if (flagDraw.isDrawJupiter) { isDrawJupiter(o, flagDrawTime); }
  // if (flagDraw.isDrawSaturn) { isDrawSaturn(o, flagDrawTime); }
  // if (flagDraw.isDrawUranus) { isDrawUranus(o, flagDrawTime); }
  // if (flagDraw.isDrawNeptune) { isDrawNeptune(o, flagDrawTime); }
  // if (flagDraw.isDrawPluto) { isDrawPluto(o, flagDrawTime); }

  svg.groupId(`出力情報`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 210})">描画開始日：${observer.initDt.toLocaleDateString()}</text>`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 180})">描画場所：${observer.name} 経度 ${observer.longitude} / 緯度 ${observer.latitude} / タイムゾーン UTC+${observer.timezone}</text>`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 150})">描画基準時刻：${flagDrawTime ? '正午／正子' : '南中／北中'}</text>`);
  svg.tag(`<text transform="translate(100,${SVG_HEIGHT - 100})">Generated by SHIKIGAMI 2.1.3 / Copyright(C)2021 Will System Design</text>`);
  svg.groupFooter();
  svg.end();

  svgImage = document.getElementById('svgImage') as HTMLElement;
  svgImage.innerHTML = svg.string;
}



/** 月 */
const isDrawMoon = (observer: observerType, flagDrawTime: boolean) => {
  const svgSmallSize = 0.4;
  const svgBigSize = 2.601;
  const strokeColor = '#231815';
  const fullmoonColor = '#FCC800', newmoonColor = '#3e3a39';
  let startDt: Date, endDt: Date, rotateHours: number;
  let drawDt: Date;
  let suntime: SuntimeType;
  let mjd: number, t: number;
  let sun: Star, moon: Satellite;
  let moonBall: { dtString: string, sunR: number, angleCos: number, sunY: number }[] = [];
  let fullmoonBall: { dtString: string, sunR: number, angleCos: number, sunY: number }[] = [];
  let newmoonBall: { dtString: string, sunR: number, angleCos: number, sunY: number }[] = [];
  let angleCos: number;
  let pre1sun: Star, pre1moon: Satellite, pre1Dt: Date, pre1Cos: number, pre1R: number, pre1Y: number, pre2Cos: number;
  let dateIndex: number;

  // 1周の描画数を決める（日数×6時間毎）
  startDt = new Date(observer.initDt);
  endDt = new Date(observer.initDt);
  endDt.setFullYear(endDt.getFullYear() + 1);
  rotateHours = (endDt.getTime() - startDt.getTime()) / (1000 * 60 * 60) / 6;

  // 最初の夜起点要素
  suntime = new SuntimeClass(observer.initDt, observer.longitude, observer.latitude, observer.timezone);
  // 正子にするか北中にするか選ぶ
  drawDt = new Date(flagDrawTime ? suntime.initDt : suntime.northDt);

  // 月波
  mjd = AstroClass.mjd(drawDt, observer.timezone);
  t = AstroClass.t(mjd);
  sun = new Sun(t);
  moon = new Moon(t);
  angleCos = -Math.cos((moon.y - sun.y) * RAD);
  moonBall[1] = { dtString: drawDt.toLocaleString(), sunR: sun.r, angleCos: angleCos, sunY: sun.y };

  // 1点前の位置を取得
  pre1Dt = new Date(drawDt);
  pre1Dt.setHours(pre1Dt.getHours() - 6);
  mjd = AstroClass.mjd(pre1Dt, observer.timezone);
  t = AstroClass.t(mjd);
  pre1sun = new Sun(t);
  pre1moon = new Moon(t);
  pre1Cos = -Math.cos((pre1moon.y - pre1sun.y) * RAD);

  // 1点前と2点前の位置を更新
  pre2Cos = pre1Cos;
  pre1Dt = new Date(drawDt);
  pre1R = sun.r;
  pre1Cos = angleCos;
  pre1Y = sun.y;

  // 最終までの夜起点要素ループ
  // 開始点から6時間毎なのでdrawDtでインクリメントする。suntimeは不要
  for (dateIndex = 2; dateIndex <= rotateHours; dateIndex++) {
    drawDt.setHours(drawDt.getHours() + 6);

    // 月玉
    mjd = AstroClass.mjd(drawDt, observer.timezone);
    t = AstroClass.t(mjd);
    sun = new Sun(t);
    moon = new Moon(t);
    angleCos = -Math.cos((moon.y - sun.y) * RAD);
    moonBall[dateIndex] = { dtString: drawDt.toLocaleString(), sunR: sun.r, angleCos: angleCos, sunY: sun.y };

    // 2点前の離角余弦＜1点前の離角余弦＞現在の離角余弦（山）なら1点前を満月とする
    if (pre2Cos < pre1Cos && pre1Cos > angleCos) {
      // 要素数があらかじめ決められないのでPushで格納
      fullmoonBall.push({ dtString: pre1Dt.toLocaleString(), sunR: pre1R, angleCos: pre1Cos, sunY: pre1Y });
    }

    // 2点前の離角余弦＞1点前の離角余弦＜現在の離角余弦（谷）なら1点前を新月とする
    if (pre2Cos > pre1Cos && pre1Cos < angleCos) {
      // 要素数があらかじめ決められないのでPushで格納
      newmoonBall.push({ dtString: pre1Dt.toLocaleString(), sunR: pre1R, angleCos: pre1Cos, sunY: pre1Y });
    }

    // 1点前と2点前の位置を更新
    pre2Cos = pre1Cos;
    pre1Dt = new Date(drawDt);
    pre1R = sun.r;
    pre1Cos = angleCos;
    pre1Y = sun.y;
  }

  // ここから月SVG生成
  svg.groupId(`月`);

  svg.groupId(`月波`);
  // 1日目だけ描画色を変えるのでループ分け
  svg.groupId(`月波 ${moonBall[1].dtString}`);
  svg.circle(moonBall[1].sunR * SVG_AUR * (1 + moonBall[1].angleCos / 20), moonBall[1].sunY, svgSmallSize, SVG_LINE_WIDTH, GREEN_COLOR, `none`);
  svg.groupFooter();

  for (dateIndex = 2; dateIndex <= rotateHours; dateIndex++) {
    svg.groupId(`月波 ${moonBall[dateIndex].dtString}`);
    svg.circle(moonBall[dateIndex].sunR * SVG_AUR * (1 + moonBall[dateIndex].angleCos / 20), moonBall[dateIndex].sunY, svgSmallSize, SVG_LINE_WIDTH, strokeColor, `none`);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`満月玉`);
  // 要素数がわからないので0始まりの要素数でループ
  for (dateIndex = 0; dateIndex <= fullmoonBall.length - 1; dateIndex++) {
    svg.groupId(`満月玉 ${fullmoonBall[dateIndex].dtString}`);
    svg.circle(fullmoonBall[dateIndex].sunR * SVG_AUR * (1 + fullmoonBall[dateIndex].angleCos / 20), fullmoonBall[dateIndex].sunY, svgBigSize, SVG_LINE_WIDTH, strokeColor, fullmoonColor);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupId(`新月玉`);
  // 要素数がわからないので0始まりの要素数でループ
  for (dateIndex = 0; dateIndex <= newmoonBall.length - 1; dateIndex++) {
    svg.groupId(`新月玉 ${newmoonBall[dateIndex].dtString}`);
    svg.circle(newmoonBall[dateIndex].sunR * SVG_AUR * (1 + newmoonBall[dateIndex].angleCos / 20), newmoonBall[dateIndex].sunY, svgBigSize, SVG_LINE_WIDTH, strokeColor, newmoonColor);
    svg.groupFooter();
  }
  svg.groupFooter();

  svg.groupFooter();
}
let defaultObject = {};
export default defaultObject;
</script>

